{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // --------- HELPERS\n\nfunction getElementOffset(el) {\n  var top = 0;\n  var left = 0;\n  var element = el; // Loop through the DOM tree\n  // and add it's parent's offset to get page offset\n\n  do {\n    top += element.offsetTop || 0;\n    left += element.offsetLeft || 0;\n    element = element.offsetParent;\n  } while (element);\n\n  return {\n    top: top,\n    left: left\n  };\n} // --------- SCROLL INTERFACES\n// ScrollDomElement and ScrollWindow have identical interfaces\n\n\nvar ScrollDomElement =\n/** @class */\nfunction () {\n  function ScrollDomElement(element) {\n    this.element = element;\n  }\n\n  ScrollDomElement.prototype.getHorizontalScroll = function () {\n    return this.element.scrollLeft;\n  };\n\n  ScrollDomElement.prototype.getVerticalScroll = function () {\n    return this.element.scrollTop;\n  };\n\n  ScrollDomElement.prototype.getMaxHorizontalScroll = function () {\n    return this.element.scrollWidth - this.element.clientWidth;\n  };\n\n  ScrollDomElement.prototype.getMaxVerticalScroll = function () {\n    return this.element.scrollHeight - this.element.clientHeight;\n  };\n\n  ScrollDomElement.prototype.getHorizontalElementScrollOffset = function (elementToScrollTo, elementToScroll) {\n    return getElementOffset(elementToScrollTo).left - getElementOffset(elementToScroll).left;\n  };\n\n  ScrollDomElement.prototype.getVerticalElementScrollOffset = function (elementToScrollTo, elementToScroll) {\n    return getElementOffset(elementToScrollTo).top - getElementOffset(elementToScroll).top;\n  };\n\n  ScrollDomElement.prototype.scrollTo = function (x, y) {\n    this.element.scrollLeft = x;\n    this.element.scrollTop = y;\n  };\n\n  return ScrollDomElement;\n}();\n\nvar ScrollWindow =\n/** @class */\nfunction () {\n  function ScrollWindow() {}\n\n  ScrollWindow.prototype.getHorizontalScroll = function () {\n    return window.scrollX || document.documentElement.scrollLeft;\n  };\n\n  ScrollWindow.prototype.getVerticalScroll = function () {\n    return window.scrollY || document.documentElement.scrollTop;\n  };\n\n  ScrollWindow.prototype.getMaxHorizontalScroll = function () {\n    return Math.max(document.body.scrollWidth, document.documentElement.scrollWidth, document.body.offsetWidth, document.documentElement.offsetWidth, document.body.clientWidth, document.documentElement.clientWidth) - window.innerWidth;\n  };\n\n  ScrollWindow.prototype.getMaxVerticalScroll = function () {\n    return Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight) - window.innerHeight;\n  };\n\n  ScrollWindow.prototype.getHorizontalElementScrollOffset = function (elementToScrollTo) {\n    var scrollLeft = window.scrollX || document.documentElement.scrollLeft;\n    return scrollLeft + elementToScrollTo.getBoundingClientRect().left;\n  };\n\n  ScrollWindow.prototype.getVerticalElementScrollOffset = function (elementToScrollTo) {\n    var scrollTop = window.scrollY || document.documentElement.scrollTop;\n    return scrollTop + elementToScrollTo.getBoundingClientRect().top;\n  };\n\n  ScrollWindow.prototype.scrollTo = function (x, y) {\n    window.scrollTo(x, y);\n  };\n\n  return ScrollWindow;\n}(); // --------- KEEPING TRACK OF ACTIVE ANIMATIONS\n\n\nvar activeAnimations = {\n  elements: [],\n  cancelMethods: [],\n  add: function (element, cancelAnimation) {\n    activeAnimations.elements.push(element);\n    activeAnimations.cancelMethods.push(cancelAnimation);\n  },\n  remove: function (element, shouldStop) {\n    if (shouldStop === void 0) {\n      shouldStop = true;\n    }\n\n    var index = activeAnimations.elements.indexOf(element);\n\n    if (index > -1) {\n      // Stop animation\n      if (shouldStop) {\n        activeAnimations.cancelMethods[index]();\n      } // Remove it\n\n\n      activeAnimations.elements.splice(index, 1);\n      activeAnimations.cancelMethods.splice(index, 1);\n    }\n  }\n}; // --------- CHECK IF CODE IS RUNNING IN A BROWSER\n\nvar WINDOW_EXISTS = typeof window !== 'undefined'; // --------- ANIMATE SCROLL TO\n\nvar defaultOptions = {\n  cancelOnUserAction: true,\n  easing: function (t) {\n    return --t * t * t + 1;\n  },\n  elementToScroll: WINDOW_EXISTS ? window : null,\n  horizontalOffset: 0,\n  maxDuration: 3000,\n  minDuration: 250,\n  speed: 500,\n  verticalOffset: 0\n};\n\nfunction animateScrollTo(numberOrCoordsOrElement, userOptions) {\n  if (userOptions === void 0) {\n    userOptions = {};\n  }\n\n  return __awaiter(this, void 0, void 0, function () {\n    var x, y, scrollToElement, options, isWindow, isElement, scrollBehaviorElement, scrollBehavior, elementToScroll, maxHorizontalScroll, initialHorizontalScroll, horizontalDistanceToScroll, maxVerticalScroll, initialVerticalScroll, verticalDistanceToScroll, horizontalDuration, verticalDuration, duration;\n    return __generator(this, function (_a) {\n      // Check for server rendering\n      if (!WINDOW_EXISTS) {\n        // @ts-ignore\n        // If it still gets called on server, return Promise for API consistency\n        return [2\n        /*return*/\n        , new Promise(function (resolve) {\n          resolve(false); // Returning false on server\n        })];\n      } else if (!window.Promise) {\n        throw 'Browser doesn\\'t support Promises, and animated-scroll-to depends on it, please provide a polyfill.';\n      }\n\n      options = __assign(__assign({}, defaultOptions), userOptions);\n      isWindow = options.elementToScroll === window;\n      isElement = !!options.elementToScroll.nodeName;\n\n      if (!isWindow && !isElement) {\n        throw 'Element to scroll needs to be either window or DOM element.';\n      }\n\n      scrollBehaviorElement = isWindow ? document.documentElement : options.elementToScroll;\n      scrollBehavior = getComputedStyle(scrollBehaviorElement).getPropertyValue('scroll-behavior');\n\n      if (scrollBehavior === 'smooth') {\n        console.warn(scrollBehaviorElement.tagName + \" has \\\"scroll-behavior: smooth\\\" which can mess up with animated-scroll-to's animations\");\n      }\n\n      elementToScroll = isWindow ? new ScrollWindow() : new ScrollDomElement(options.elementToScroll);\n\n      if (numberOrCoordsOrElement instanceof Element) {\n        scrollToElement = numberOrCoordsOrElement; // If \"elementToScroll\" is not a parent of \"scrollToElement\"\n\n        if (isElement && (!options.elementToScroll.contains(scrollToElement) || options.elementToScroll.isSameNode(scrollToElement))) {\n          throw 'options.elementToScroll has to be a parent of scrollToElement';\n        }\n\n        x = elementToScroll.getHorizontalElementScrollOffset(scrollToElement, options.elementToScroll);\n        y = elementToScroll.getVerticalElementScrollOffset(scrollToElement, options.elementToScroll);\n      } else if (typeof numberOrCoordsOrElement === 'number') {\n        x = elementToScroll.getHorizontalScroll();\n        y = numberOrCoordsOrElement;\n      } else if (Array.isArray(numberOrCoordsOrElement) && numberOrCoordsOrElement.length === 2) {\n        x = numberOrCoordsOrElement[0] === null ? elementToScroll.getHorizontalScroll() : numberOrCoordsOrElement[0];\n        y = numberOrCoordsOrElement[1] === null ? elementToScroll.getVerticalScroll() : numberOrCoordsOrElement[1];\n      } else {\n        // ERROR\n        throw 'Wrong function signature. Check documentation.\\n' + 'Available method signatures are:\\n' + '  animateScrollTo(y:number, options)\\n' + '  animateScrollTo([x:number | null, y:number | null], options)\\n' + '  animateScrollTo(scrollToElement:Element, options)';\n      } // Add offsets\n\n\n      x += options.horizontalOffset;\n      y += options.verticalOffset;\n      maxHorizontalScroll = elementToScroll.getMaxHorizontalScroll();\n      initialHorizontalScroll = elementToScroll.getHorizontalScroll(); // If user specified scroll position is greater than maximum available scroll\n\n      if (x > maxHorizontalScroll) {\n        x = maxHorizontalScroll;\n      }\n\n      horizontalDistanceToScroll = x - initialHorizontalScroll;\n      maxVerticalScroll = elementToScroll.getMaxVerticalScroll();\n      initialVerticalScroll = elementToScroll.getVerticalScroll(); // If user specified scroll position is greater than maximum available scroll\n\n      if (y > maxVerticalScroll) {\n        y = maxVerticalScroll;\n      }\n\n      verticalDistanceToScroll = y - initialVerticalScroll;\n      horizontalDuration = Math.abs(Math.round(horizontalDistanceToScroll / 1000 * options.speed));\n      verticalDuration = Math.abs(Math.round(verticalDistanceToScroll / 1000 * options.speed));\n      duration = horizontalDuration > verticalDuration ? horizontalDuration : verticalDuration; // Set minimum and maximum duration\n\n      if (duration < options.minDuration) {\n        duration = options.minDuration;\n      } else if (duration > options.maxDuration) {\n        duration = options.maxDuration;\n      } // @ts-ignore\n\n\n      return [2\n      /*return*/\n      , new Promise(function (resolve, reject) {\n        // Scroll is already in place, nothing to do\n        if (horizontalDistanceToScroll === 0 && verticalDistanceToScroll === 0) {\n          // Resolve promise with a boolean hasScrolledToPosition set to true\n          resolve(true);\n        } // Cancel existing animation if it is already running on the same element\n\n\n        activeAnimations.remove(options.elementToScroll, true); // To cancel animation we have to store request animation frame ID \n\n        var requestID; // Cancel animation handler\n\n        var cancelAnimation = function () {\n          removeListeners();\n          cancelAnimationFrame(requestID); // Resolve promise with a boolean hasScrolledToPosition set to false\n\n          resolve(false);\n        }; // Registering animation so it can be canceled if function\n        // gets called again on the same element\n\n\n        activeAnimations.add(options.elementToScroll, cancelAnimation); // Prevent user actions handler\n\n        var preventDefaultHandler = function (e) {\n          return e.preventDefault();\n        };\n\n        var handler = options.cancelOnUserAction ? cancelAnimation : preventDefaultHandler; // If animation is not cancelable by the user, we can't use passive events\n\n        var eventOptions = options.cancelOnUserAction ? {\n          passive: true\n        } : {\n          passive: false\n        };\n        var events = ['wheel', 'touchstart', 'keydown', 'mousedown']; // Function to remove listeners after animation is finished\n\n        var removeListeners = function () {\n          events.forEach(function (eventName) {\n            options.elementToScroll.removeEventListener(eventName, handler, eventOptions);\n          });\n        }; // Add listeners\n\n\n        events.forEach(function (eventName) {\n          options.elementToScroll.addEventListener(eventName, handler, eventOptions);\n        }); // Animation\n\n        var startingTime = Date.now();\n\n        var step = function () {\n          var timeDiff = Date.now() - startingTime;\n          var t = timeDiff / duration;\n          var horizontalScrollPosition = Math.round(initialHorizontalScroll + horizontalDistanceToScroll * options.easing(t));\n          var verticalScrollPosition = Math.round(initialVerticalScroll + verticalDistanceToScroll * options.easing(t));\n\n          if (timeDiff < duration && (horizontalScrollPosition !== x || verticalScrollPosition !== y)) {\n            // If scroll didn't reach desired position or time is not elapsed\n            // Scroll to a new position\n            elementToScroll.scrollTo(horizontalScrollPosition, verticalScrollPosition); // And request a new step\n\n            requestID = requestAnimationFrame(step);\n          } else {\n            // If the time elapsed or we reached the desired offset\n            // Set scroll to the desired offset (when rounding made it to be off a pixel or two)\n            // Clear animation frame to be sure\n            elementToScroll.scrollTo(x, y);\n            cancelAnimationFrame(requestID); // Remove listeners\n\n            removeListeners(); // Remove animation from the active animations coordinator\n\n            activeAnimations.remove(options.elementToScroll, false); // Resolve promise with a boolean hasScrolledToPosition set to true\n\n            resolve(true);\n          }\n        }; // Start animating scroll\n\n\n        requestID = requestAnimationFrame(step);\n      })];\n    });\n  });\n}\n\nexports.default = animateScrollTo;","map":{"version":3,"sources":["C:/Users/King/Desktop/batcave/superstarztype/node_modules/animated-scroll-to/lib/animated-scroll-to.js"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","__generator","body","_","label","sent","trys","ops","f","y","g","verb","Symbol","iterator","v","op","TypeError","pop","push","defineProperty","exports","getElementOffset","el","top","left","element","offsetTop","offsetLeft","offsetParent","ScrollDomElement","getHorizontalScroll","scrollLeft","getVerticalScroll","scrollTop","getMaxHorizontalScroll","scrollWidth","clientWidth","getMaxVerticalScroll","scrollHeight","clientHeight","getHorizontalElementScrollOffset","elementToScrollTo","elementToScroll","getVerticalElementScrollOffset","scrollTo","x","ScrollWindow","window","scrollX","document","documentElement","scrollY","Math","max","offsetWidth","innerWidth","offsetHeight","innerHeight","getBoundingClientRect","activeAnimations","elements","cancelMethods","add","cancelAnimation","remove","shouldStop","index","indexOf","splice","WINDOW_EXISTS","defaultOptions","cancelOnUserAction","easing","horizontalOffset","maxDuration","minDuration","speed","verticalOffset","animateScrollTo","numberOrCoordsOrElement","userOptions","scrollToElement","options","isWindow","isElement","scrollBehaviorElement","scrollBehavior","maxHorizontalScroll","initialHorizontalScroll","horizontalDistanceToScroll","maxVerticalScroll","initialVerticalScroll","verticalDistanceToScroll","horizontalDuration","verticalDuration","duration","_a","nodeName","getComputedStyle","getPropertyValue","console","warn","tagName","Element","contains","isSameNode","Array","isArray","abs","round","requestID","removeListeners","cancelAnimationFrame","preventDefaultHandler","preventDefault","handler","eventOptions","passive","events","forEach","eventName","removeEventListener","addEventListener","startingTime","Date","now","timeDiff","horizontalScrollPosition","verticalScrollPosition","requestAnimationFrame","default"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// --------- HELPERS\nfunction getElementOffset(el) {\n    var top = 0;\n    var left = 0;\n    var element = el;\n    // Loop through the DOM tree\n    // and add it's parent's offset to get page offset\n    do {\n        top += element.offsetTop || 0;\n        left += element.offsetLeft || 0;\n        element = element.offsetParent;\n    } while (element);\n    return {\n        top: top,\n        left: left,\n    };\n}\n// --------- SCROLL INTERFACES\n// ScrollDomElement and ScrollWindow have identical interfaces\nvar ScrollDomElement = /** @class */ (function () {\n    function ScrollDomElement(element) {\n        this.element = element;\n    }\n    ScrollDomElement.prototype.getHorizontalScroll = function () {\n        return this.element.scrollLeft;\n    };\n    ScrollDomElement.prototype.getVerticalScroll = function () {\n        return this.element.scrollTop;\n    };\n    ScrollDomElement.prototype.getMaxHorizontalScroll = function () {\n        return this.element.scrollWidth - this.element.clientWidth;\n    };\n    ScrollDomElement.prototype.getMaxVerticalScroll = function () {\n        return this.element.scrollHeight - this.element.clientHeight;\n    };\n    ScrollDomElement.prototype.getHorizontalElementScrollOffset = function (elementToScrollTo, elementToScroll) {\n        return getElementOffset(elementToScrollTo).left - getElementOffset(elementToScroll).left;\n    };\n    ScrollDomElement.prototype.getVerticalElementScrollOffset = function (elementToScrollTo, elementToScroll) {\n        return getElementOffset(elementToScrollTo).top - getElementOffset(elementToScroll).top;\n    };\n    ScrollDomElement.prototype.scrollTo = function (x, y) {\n        this.element.scrollLeft = x;\n        this.element.scrollTop = y;\n    };\n    return ScrollDomElement;\n}());\nvar ScrollWindow = /** @class */ (function () {\n    function ScrollWindow() {\n    }\n    ScrollWindow.prototype.getHorizontalScroll = function () {\n        return window.scrollX || document.documentElement.scrollLeft;\n    };\n    ScrollWindow.prototype.getVerticalScroll = function () {\n        return window.scrollY || document.documentElement.scrollTop;\n    };\n    ScrollWindow.prototype.getMaxHorizontalScroll = function () {\n        return Math.max(document.body.scrollWidth, document.documentElement.scrollWidth, document.body.offsetWidth, document.documentElement.offsetWidth, document.body.clientWidth, document.documentElement.clientWidth) - window.innerWidth;\n    };\n    ScrollWindow.prototype.getMaxVerticalScroll = function () {\n        return Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight) - window.innerHeight;\n    };\n    ScrollWindow.prototype.getHorizontalElementScrollOffset = function (elementToScrollTo) {\n        var scrollLeft = window.scrollX || document.documentElement.scrollLeft;\n        return scrollLeft + elementToScrollTo.getBoundingClientRect().left;\n    };\n    ScrollWindow.prototype.getVerticalElementScrollOffset = function (elementToScrollTo) {\n        var scrollTop = window.scrollY || document.documentElement.scrollTop;\n        return scrollTop + elementToScrollTo.getBoundingClientRect().top;\n    };\n    ScrollWindow.prototype.scrollTo = function (x, y) {\n        window.scrollTo(x, y);\n    };\n    return ScrollWindow;\n}());\n// --------- KEEPING TRACK OF ACTIVE ANIMATIONS\nvar activeAnimations = {\n    elements: [],\n    cancelMethods: [],\n    add: function (element, cancelAnimation) {\n        activeAnimations.elements.push(element);\n        activeAnimations.cancelMethods.push(cancelAnimation);\n    },\n    remove: function (element, shouldStop) {\n        if (shouldStop === void 0) { shouldStop = true; }\n        var index = activeAnimations.elements.indexOf(element);\n        if (index > -1) {\n            // Stop animation\n            if (shouldStop) {\n                activeAnimations.cancelMethods[index]();\n            }\n            // Remove it\n            activeAnimations.elements.splice(index, 1);\n            activeAnimations.cancelMethods.splice(index, 1);\n        }\n    }\n};\n// --------- CHECK IF CODE IS RUNNING IN A BROWSER\nvar WINDOW_EXISTS = typeof window !== 'undefined';\n// --------- ANIMATE SCROLL TO\nvar defaultOptions = {\n    cancelOnUserAction: true,\n    easing: function (t) { return (--t) * t * t + 1; },\n    elementToScroll: WINDOW_EXISTS ? window : null,\n    horizontalOffset: 0,\n    maxDuration: 3000,\n    minDuration: 250,\n    speed: 500,\n    verticalOffset: 0,\n};\nfunction animateScrollTo(numberOrCoordsOrElement, userOptions) {\n    if (userOptions === void 0) { userOptions = {}; }\n    return __awaiter(this, void 0, void 0, function () {\n        var x, y, scrollToElement, options, isWindow, isElement, scrollBehaviorElement, scrollBehavior, elementToScroll, maxHorizontalScroll, initialHorizontalScroll, horizontalDistanceToScroll, maxVerticalScroll, initialVerticalScroll, verticalDistanceToScroll, horizontalDuration, verticalDuration, duration;\n        return __generator(this, function (_a) {\n            // Check for server rendering\n            if (!WINDOW_EXISTS) {\n                // @ts-ignore\n                // If it still gets called on server, return Promise for API consistency\n                return [2 /*return*/, new Promise(function (resolve) {\n                        resolve(false); // Returning false on server\n                    })];\n            }\n            else if (!window.Promise) {\n                throw ('Browser doesn\\'t support Promises, and animated-scroll-to depends on it, please provide a polyfill.');\n            }\n            options = __assign(__assign({}, defaultOptions), userOptions);\n            isWindow = options.elementToScroll === window;\n            isElement = !!options.elementToScroll.nodeName;\n            if (!isWindow && !isElement) {\n                throw ('Element to scroll needs to be either window or DOM element.');\n            }\n            scrollBehaviorElement = isWindow ? document.documentElement : options.elementToScroll;\n            scrollBehavior = getComputedStyle(scrollBehaviorElement).getPropertyValue('scroll-behavior');\n            if (scrollBehavior === 'smooth') {\n                console.warn(scrollBehaviorElement.tagName + \" has \\\"scroll-behavior: smooth\\\" which can mess up with animated-scroll-to's animations\");\n            }\n            elementToScroll = isWindow ?\n                new ScrollWindow() :\n                new ScrollDomElement(options.elementToScroll);\n            if (numberOrCoordsOrElement instanceof Element) {\n                scrollToElement = numberOrCoordsOrElement;\n                // If \"elementToScroll\" is not a parent of \"scrollToElement\"\n                if (isElement &&\n                    (!options.elementToScroll.contains(scrollToElement) ||\n                        options.elementToScroll.isSameNode(scrollToElement))) {\n                    throw ('options.elementToScroll has to be a parent of scrollToElement');\n                }\n                x = elementToScroll.getHorizontalElementScrollOffset(scrollToElement, options.elementToScroll);\n                y = elementToScroll.getVerticalElementScrollOffset(scrollToElement, options.elementToScroll);\n            }\n            else if (typeof numberOrCoordsOrElement === 'number') {\n                x = elementToScroll.getHorizontalScroll();\n                y = numberOrCoordsOrElement;\n            }\n            else if (Array.isArray(numberOrCoordsOrElement) && numberOrCoordsOrElement.length === 2) {\n                x = numberOrCoordsOrElement[0] === null ? elementToScroll.getHorizontalScroll() : numberOrCoordsOrElement[0];\n                y = numberOrCoordsOrElement[1] === null ? elementToScroll.getVerticalScroll() : numberOrCoordsOrElement[1];\n            }\n            else {\n                // ERROR\n                throw ('Wrong function signature. Check documentation.\\n' +\n                    'Available method signatures are:\\n' +\n                    '  animateScrollTo(y:number, options)\\n' +\n                    '  animateScrollTo([x:number | null, y:number | null], options)\\n' +\n                    '  animateScrollTo(scrollToElement:Element, options)');\n            }\n            // Add offsets\n            x += options.horizontalOffset;\n            y += options.verticalOffset;\n            maxHorizontalScroll = elementToScroll.getMaxHorizontalScroll();\n            initialHorizontalScroll = elementToScroll.getHorizontalScroll();\n            // If user specified scroll position is greater than maximum available scroll\n            if (x > maxHorizontalScroll) {\n                x = maxHorizontalScroll;\n            }\n            horizontalDistanceToScroll = x - initialHorizontalScroll;\n            maxVerticalScroll = elementToScroll.getMaxVerticalScroll();\n            initialVerticalScroll = elementToScroll.getVerticalScroll();\n            // If user specified scroll position is greater than maximum available scroll\n            if (y > maxVerticalScroll) {\n                y = maxVerticalScroll;\n            }\n            verticalDistanceToScroll = y - initialVerticalScroll;\n            horizontalDuration = Math.abs(Math.round((horizontalDistanceToScroll / 1000) * options.speed));\n            verticalDuration = Math.abs(Math.round((verticalDistanceToScroll / 1000) * options.speed));\n            duration = horizontalDuration > verticalDuration ? horizontalDuration : verticalDuration;\n            // Set minimum and maximum duration\n            if (duration < options.minDuration) {\n                duration = options.minDuration;\n            }\n            else if (duration > options.maxDuration) {\n                duration = options.maxDuration;\n            }\n            // @ts-ignore\n            return [2 /*return*/, new Promise(function (resolve, reject) {\n                    // Scroll is already in place, nothing to do\n                    if (horizontalDistanceToScroll === 0 && verticalDistanceToScroll === 0) {\n                        // Resolve promise with a boolean hasScrolledToPosition set to true\n                        resolve(true);\n                    }\n                    // Cancel existing animation if it is already running on the same element\n                    activeAnimations.remove(options.elementToScroll, true);\n                    // To cancel animation we have to store request animation frame ID \n                    var requestID;\n                    // Cancel animation handler\n                    var cancelAnimation = function () {\n                        removeListeners();\n                        cancelAnimationFrame(requestID);\n                        // Resolve promise with a boolean hasScrolledToPosition set to false\n                        resolve(false);\n                    };\n                    // Registering animation so it can be canceled if function\n                    // gets called again on the same element\n                    activeAnimations.add(options.elementToScroll, cancelAnimation);\n                    // Prevent user actions handler\n                    var preventDefaultHandler = function (e) { return e.preventDefault(); };\n                    var handler = options.cancelOnUserAction ?\n                        cancelAnimation :\n                        preventDefaultHandler;\n                    // If animation is not cancelable by the user, we can't use passive events\n                    var eventOptions = options.cancelOnUserAction ?\n                        { passive: true } :\n                        { passive: false };\n                    var events = [\n                        'wheel',\n                        'touchstart',\n                        'keydown',\n                        'mousedown',\n                    ];\n                    // Function to remove listeners after animation is finished\n                    var removeListeners = function () {\n                        events.forEach(function (eventName) {\n                            options.elementToScroll.removeEventListener(eventName, handler, eventOptions);\n                        });\n                    };\n                    // Add listeners\n                    events.forEach(function (eventName) {\n                        options.elementToScroll.addEventListener(eventName, handler, eventOptions);\n                    });\n                    // Animation\n                    var startingTime = Date.now();\n                    var step = function () {\n                        var timeDiff = Date.now() - startingTime;\n                        var t = timeDiff / duration;\n                        var horizontalScrollPosition = Math.round(initialHorizontalScroll + (horizontalDistanceToScroll * options.easing(t)));\n                        var verticalScrollPosition = Math.round(initialVerticalScroll + (verticalDistanceToScroll * options.easing(t)));\n                        if (timeDiff < duration && (horizontalScrollPosition !== x || verticalScrollPosition !== y)) {\n                            // If scroll didn't reach desired position or time is not elapsed\n                            // Scroll to a new position\n                            elementToScroll.scrollTo(horizontalScrollPosition, verticalScrollPosition);\n                            // And request a new step\n                            requestID = requestAnimationFrame(step);\n                        }\n                        else {\n                            // If the time elapsed or we reached the desired offset\n                            // Set scroll to the desired offset (when rounding made it to be off a pixel or two)\n                            // Clear animation frame to be sure\n                            elementToScroll.scrollTo(x, y);\n                            cancelAnimationFrame(requestID);\n                            // Remove listeners\n                            removeListeners();\n                            // Remove animation from the active animations coordinator\n                            activeAnimations.remove(options.elementToScroll, false);\n                            // Resolve promise with a boolean hasScrolledToPosition set to true\n                            resolve(true);\n                        }\n                    };\n                    // Start animating scroll\n                    requestID = requestAnimationFrame(step);\n                })];\n        });\n    });\n}\nexports.default = animateScrollTo;\n"]},"metadata":{},"sourceType":"script"}