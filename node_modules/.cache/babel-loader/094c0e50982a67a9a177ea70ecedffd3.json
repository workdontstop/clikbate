{"ast":null,"code":"import { __assign, __extends } from 'tslib';\nimport React from 'react';\nimport normalizeWheel from 'normalize-wheel';\n\n/**\r\n * Compute the dimension of the crop area based on media size,\r\n * aspect ratio and optionally rotation\r\n */\nfunction getCropSize(mediaWidth, mediaHeight, containerWidth, containerHeight, aspect, rotation) {\n  if (rotation === void 0) {\n    rotation = 0;\n  }\n  var _a = rotateSize(mediaWidth, mediaHeight, rotation),\n    width = _a.width,\n    height = _a.height;\n  var fittingWidth = Math.min(width, containerWidth);\n  var fittingHeight = Math.min(height, containerHeight);\n  if (fittingWidth > fittingHeight * aspect) {\n    return {\n      width: fittingHeight * aspect,\n      height: fittingHeight\n    };\n  }\n  return {\n    width: fittingWidth,\n    height: fittingWidth / aspect\n  };\n}\n/**\r\n * Compute media zoom.\r\n * We fit the media into the container with \"max-width: 100%; max-height: 100%;\"\r\n */\nfunction getMediaZoom(mediaSize) {\n  // Take the axis with more pixels to improve accuracy\n  return mediaSize.width > mediaSize.height ? mediaSize.width / mediaSize.naturalWidth : mediaSize.height / mediaSize.naturalHeight;\n}\n/**\r\n * Ensure a new media position stays in the crop area.\r\n */\nfunction restrictPosition(position, mediaSize, cropSize, zoom, rotation) {\n  if (rotation === void 0) {\n    rotation = 0;\n  }\n  var _a = rotateSize(mediaSize.width, mediaSize.height, rotation),\n    width = _a.width,\n    height = _a.height;\n  return {\n    x: restrictPositionCoord(position.x, width, cropSize.width, zoom),\n    y: restrictPositionCoord(position.y, height, cropSize.height, zoom)\n  };\n}\nfunction restrictPositionCoord(position, mediaSize, cropSize, zoom) {\n  var maxPosition = mediaSize * zoom / 2 - cropSize / 2;\n  return clamp(position, -maxPosition, maxPosition);\n}\nfunction getDistanceBetweenPoints(pointA, pointB) {\n  return Math.sqrt(Math.pow(pointA.y - pointB.y, 2) + Math.pow(pointA.x - pointB.x, 2));\n}\nfunction getRotationBetweenPoints(pointA, pointB) {\n  return Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180 / Math.PI;\n}\n/**\r\n * Compute the output cropped area of the media in percentages and pixels.\r\n * x/y are the top-left coordinates on the src media\r\n */\nfunction computeCroppedArea(crop, mediaSize, cropSize, aspect, zoom, rotation, restrictPosition) {\n  if (rotation === void 0) {\n    rotation = 0;\n  }\n  if (restrictPosition === void 0) {\n    restrictPosition = true;\n  }\n  // if the media is rotated by the user, we cannot limit the position anymore\n  // as it might need to be negative.\n  var limitAreaFn = restrictPosition ? limitArea : noOp;\n  var mediaBBoxSize = rotateSize(mediaSize.width, mediaSize.height, rotation);\n  var mediaNaturalBBoxSize = rotateSize(mediaSize.naturalWidth, mediaSize.naturalHeight, rotation);\n  // calculate the crop area in percentages\n  // in the rotated space\n  var croppedAreaPercentages = {\n    x: limitAreaFn(100, ((mediaBBoxSize.width - cropSize.width / zoom) / 2 - crop.x / zoom) / mediaBBoxSize.width * 100),\n    y: limitAreaFn(100, ((mediaBBoxSize.height - cropSize.height / zoom) / 2 - crop.y / zoom) / mediaBBoxSize.height * 100),\n    width: limitAreaFn(100, cropSize.width / mediaBBoxSize.width * 100 / zoom),\n    height: limitAreaFn(100, cropSize.height / mediaBBoxSize.height * 100 / zoom)\n  };\n  // we compute the pixels size naively\n  var widthInPixels = Math.round(limitAreaFn(mediaNaturalBBoxSize.width, croppedAreaPercentages.width * mediaNaturalBBoxSize.width / 100));\n  var heightInPixels = Math.round(limitAreaFn(mediaNaturalBBoxSize.height, croppedAreaPercentages.height * mediaNaturalBBoxSize.height / 100));\n  var isImgWiderThanHigh = mediaNaturalBBoxSize.width >= mediaNaturalBBoxSize.height * aspect;\n  // then we ensure the width and height exactly match the aspect (to avoid rounding approximations)\n  // if the media is wider than high, when zoom is 0, the crop height will be equals to image height\n  // thus we want to compute the width from the height and aspect for accuracy.\n  // Otherwise, we compute the height from width and aspect.\n  var sizePixels = isImgWiderThanHigh ? {\n    width: Math.round(heightInPixels * aspect),\n    height: heightInPixels\n  } : {\n    width: widthInPixels,\n    height: Math.round(widthInPixels / aspect)\n  };\n  var croppedAreaPixels = __assign(__assign({}, sizePixels), {\n    x: Math.round(limitAreaFn(mediaNaturalBBoxSize.width - sizePixels.width, croppedAreaPercentages.x * mediaNaturalBBoxSize.width / 100)),\n    y: Math.round(limitAreaFn(mediaNaturalBBoxSize.height - sizePixels.height, croppedAreaPercentages.y * mediaNaturalBBoxSize.height / 100))\n  });\n  return {\n    croppedAreaPercentages: croppedAreaPercentages,\n    croppedAreaPixels: croppedAreaPixels\n  };\n}\n/**\r\n * Ensure the returned value is between 0 and max\r\n */\nfunction limitArea(max, value) {\n  return Math.min(max, Math.max(0, value));\n}\nfunction noOp(_max, value) {\n  return value;\n}\n/**\r\n * Compute crop and zoom from the croppedAreaPercentages.\r\n */\nfunction getInitialCropFromCroppedAreaPercentages(croppedAreaPercentages, mediaSize, rotation, cropSize, minZoom, maxZoom) {\n  var mediaBBoxSize = rotateSize(mediaSize.width, mediaSize.height, rotation);\n  // This is the inverse process of computeCroppedArea\n  var zoom = clamp(cropSize.width / mediaBBoxSize.width * (100 / croppedAreaPercentages.width), minZoom, maxZoom);\n  var crop = {\n    x: zoom * mediaBBoxSize.width / 2 - cropSize.width / 2 - mediaBBoxSize.width * zoom * (croppedAreaPercentages.x / 100),\n    y: zoom * mediaBBoxSize.height / 2 - cropSize.height / 2 - mediaBBoxSize.height * zoom * (croppedAreaPercentages.y / 100)\n  };\n  return {\n    crop: crop,\n    zoom: zoom\n  };\n}\n/**\r\n * Compute zoom from the croppedAreaPixels\r\n */\nfunction getZoomFromCroppedAreaPixels(croppedAreaPixels, mediaSize, cropSize) {\n  var mediaZoom = getMediaZoom(mediaSize);\n  return cropSize.height > cropSize.width ? cropSize.height / (croppedAreaPixels.height * mediaZoom) : cropSize.width / (croppedAreaPixels.width * mediaZoom);\n}\n/**\r\n * Compute crop and zoom from the croppedAreaPixels\r\n */\nfunction getInitialCropFromCroppedAreaPixels(croppedAreaPixels, mediaSize, rotation, cropSize, minZoom, maxZoom) {\n  if (rotation === void 0) {\n    rotation = 0;\n  }\n  var mediaNaturalBBoxSize = rotateSize(mediaSize.naturalWidth, mediaSize.naturalHeight, rotation);\n  var zoom = clamp(getZoomFromCroppedAreaPixels(croppedAreaPixels, mediaSize, cropSize), minZoom, maxZoom);\n  var cropZoom = cropSize.height > cropSize.width ? cropSize.height / croppedAreaPixels.height : cropSize.width / croppedAreaPixels.width;\n  var crop = {\n    x: ((mediaNaturalBBoxSize.width - croppedAreaPixels.width) / 2 - croppedAreaPixels.x) * cropZoom,\n    y: ((mediaNaturalBBoxSize.height - croppedAreaPixels.height) / 2 - croppedAreaPixels.y) * cropZoom\n  };\n  return {\n    crop: crop,\n    zoom: zoom\n  };\n}\n/**\r\n * Return the point that is the center of point a and b\r\n */\nfunction getCenter(a, b) {\n  return {\n    x: (b.x + a.x) / 2,\n    y: (b.y + a.y) / 2\n  };\n}\nfunction getRadianAngle(degreeValue) {\n  return degreeValue * Math.PI / 180;\n}\n/**\r\n * Returns the new bounding area of a rotated rectangle.\r\n */\nfunction rotateSize(width, height, rotation) {\n  var rotRad = getRadianAngle(rotation);\n  return {\n    width: Math.abs(Math.cos(rotRad) * width) + Math.abs(Math.sin(rotRad) * height),\n    height: Math.abs(Math.sin(rotRad) * width) + Math.abs(Math.cos(rotRad) * height)\n  };\n}\n/**\r\n * Clamp value between min and max\r\n */\nfunction clamp(value, min, max) {\n  return Math.min(Math.max(value, min), max);\n}\n/**\r\n * Combine multiple class names into a single string.\r\n */\nfunction classNames() {\n  var args = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n  return args.filter(function (value) {\n    if (typeof value === 'string' && value.length > 0) {\n      return true;\n    }\n    return false;\n  }).join(' ').trim();\n}\nvar css_248z = \".reactEasyCrop_Container {\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  right: 0;\\n  bottom: 0;\\n  overflow: hidden;\\n  user-select: none;\\n  touch-action: none;\\n  cursor: move;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n}\\n\\n.reactEasyCrop_Image,\\n.reactEasyCrop_Video {\\n  will-change: transform; /* this improves performances and prevent painting issues on iOS Chrome */\\n}\\n\\n.reactEasyCrop_Contain {\\n  max-width: 100%;\\n  max-height: 100%;\\n  margin: auto;\\n  position: absolute;\\n  top: 0;\\n  bottom: 0;\\n  left: 0;\\n  right: 0;\\n}\\n.reactEasyCrop_Cover_Horizontal {\\n  width: 100%;\\n  height: auto;\\n}\\n.reactEasyCrop_Cover_Vertical {\\n  width: auto;\\n  height: 100%;\\n}\\n\\n.reactEasyCrop_CropArea {\\n  position: absolute;\\n  left: 50%;\\n  top: 50%;\\n  transform: translate(-50%, -50%);\\n  border: 1px solid rgba(255, 255, 255, 0.5);\\n  box-sizing: border-box;\\n  box-shadow: 0 0 0 9999em;\\n  color: rgba(0, 0, 0, 0.5);\\n  overflow: hidden;\\n}\\n\\n.reactEasyCrop_CropAreaRound {\\n  border-radius: 50%;\\n}\\n\\n.reactEasyCrop_CropAreaGrid::before {\\n  content: ' ';\\n  box-sizing: border-box;\\n  position: absolute;\\n  border: 1px solid rgba(255, 255, 255, 0.5);\\n  top: 0;\\n  bottom: 0;\\n  left: 33.33%;\\n  right: 33.33%;\\n  border-top: 0;\\n  border-bottom: 0;\\n}\\n\\n.reactEasyCrop_CropAreaGrid::after {\\n  content: ' ';\\n  box-sizing: border-box;\\n  position: absolute;\\n  border: 1px solid rgba(255, 255, 255, 0.5);\\n  top: 33.33%;\\n  bottom: 33.33%;\\n  left: 0;\\n  right: 0;\\n  border-left: 0;\\n  border-right: 0;\\n}\\n\";\nvar MIN_ZOOM = 1;\nvar MAX_ZOOM = 3;\nvar Cropper = /** @class */function (_super) {\n  __extends(Cropper, _super);\n  function Cropper() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.imageRef = React.createRef();\n    _this.videoRef = React.createRef();\n    _this.containerRef = null;\n    _this.styleRef = null;\n    _this.containerRect = null;\n    _this.mediaSize = {\n      width: 0,\n      height: 0,\n      naturalWidth: 0,\n      naturalHeight: 0\n    };\n    _this.dragStartPosition = {\n      x: 0,\n      y: 0\n    };\n    _this.dragStartCrop = {\n      x: 0,\n      y: 0\n    };\n    _this.gestureZoomStart = 0;\n    _this.gestureRotationStart = 0;\n    _this.isTouching = false;\n    _this.lastPinchDistance = 0;\n    _this.lastPinchRotation = 0;\n    _this.rafDragTimeout = null;\n    _this.rafPinchTimeout = null;\n    _this.wheelTimer = null;\n    _this.currentDoc = typeof document !== 'undefined' ? document : null;\n    _this.currentWindow = typeof window !== 'undefined' ? window : null;\n    _this.resizeObserver = null;\n    _this.state = {\n      cropSize: null,\n      hasWheelJustStarted: false\n    };\n    _this.initResizeObserver = function () {\n      if (typeof window.ResizeObserver === 'undefined' || !_this.containerRef) {\n        return;\n      }\n      var isFirstResize = true;\n      _this.resizeObserver = new window.ResizeObserver(function (entries) {\n        if (isFirstResize) {\n          isFirstResize = false; // observe() is called on mount, we don't want to trigger a recompute on mount\n          return;\n        }\n        _this.computeSizes();\n      });\n      _this.resizeObserver.observe(_this.containerRef);\n    };\n    // this is to prevent Safari on iOS >= 10 to zoom the page\n    _this.preventZoomSafari = function (e) {\n      return e.preventDefault();\n    };\n    _this.cleanEvents = function () {\n      if (!_this.currentDoc) return;\n      _this.currentDoc.removeEventListener('mousemove', _this.onMouseMove);\n      _this.currentDoc.removeEventListener('mouseup', _this.onDragStopped);\n      _this.currentDoc.removeEventListener('touchmove', _this.onTouchMove);\n      _this.currentDoc.removeEventListener('touchend', _this.onDragStopped);\n      _this.currentDoc.removeEventListener('gesturemove', _this.onGestureMove);\n      _this.currentDoc.removeEventListener('gestureend', _this.onGestureEnd);\n    };\n    _this.clearScrollEvent = function () {\n      if (_this.containerRef) _this.containerRef.removeEventListener('wheel', _this.onWheel);\n      if (_this.wheelTimer) {\n        clearTimeout(_this.wheelTimer);\n      }\n    };\n    _this.onMediaLoad = function () {\n      var cropSize = _this.computeSizes();\n      if (cropSize) {\n        _this.emitCropData();\n        _this.setInitialCrop(cropSize);\n      }\n      if (_this.props.onMediaLoaded) {\n        _this.props.onMediaLoaded(_this.mediaSize);\n      }\n    };\n    _this.setInitialCrop = function (cropSize) {\n      if (_this.props.initialCroppedAreaPercentages) {\n        var _a = getInitialCropFromCroppedAreaPercentages(_this.props.initialCroppedAreaPercentages, _this.mediaSize, _this.props.rotation, cropSize, _this.props.minZoom, _this.props.maxZoom),\n          crop = _a.crop,\n          zoom = _a.zoom;\n        _this.props.onCropChange(crop);\n        _this.props.onZoomChange && _this.props.onZoomChange(zoom);\n      } else if (_this.props.initialCroppedAreaPixels) {\n        var _b = getInitialCropFromCroppedAreaPixels(_this.props.initialCroppedAreaPixels, _this.mediaSize, _this.props.rotation, cropSize, _this.props.minZoom, _this.props.maxZoom),\n          crop = _b.crop,\n          zoom = _b.zoom;\n        _this.props.onCropChange(crop);\n        _this.props.onZoomChange && _this.props.onZoomChange(zoom);\n      }\n    };\n    _this.computeSizes = function () {\n      var _a, _b, _c, _d, _e, _f;\n      var mediaRef = _this.imageRef.current || _this.videoRef.current;\n      if (mediaRef && _this.containerRef) {\n        _this.containerRect = _this.containerRef.getBoundingClientRect();\n        var containerAspect = _this.containerRect.width / _this.containerRect.height;\n        var naturalWidth = ((_a = _this.imageRef.current) === null || _a === void 0 ? void 0 : _a.naturalWidth) || ((_b = _this.videoRef.current) === null || _b === void 0 ? void 0 : _b.videoWidth) || 0;\n        var naturalHeight = ((_c = _this.imageRef.current) === null || _c === void 0 ? void 0 : _c.naturalHeight) || ((_d = _this.videoRef.current) === null || _d === void 0 ? void 0 : _d.videoHeight) || 0;\n        var isMediaScaledDown = mediaRef.offsetWidth < naturalWidth || mediaRef.offsetHeight < naturalHeight;\n        var mediaAspect = naturalWidth / naturalHeight;\n        // We do not rely on the offsetWidth/offsetHeight if the media is scaled down\n        // as the values they report are rounded. That will result in precision losses\n        // when calculating zoom. We use the fact that the media is positionned relative\n        // to the container. That allows us to use the container's dimensions\n        // and natural aspect ratio of the media to calculate accurate media size.\n        // However, for this to work, the container should not be rotated\n        var renderedMediaSize = void 0;\n        if (isMediaScaledDown) {\n          switch (_this.props.objectFit) {\n            default:\n            case 'contain':\n              renderedMediaSize = containerAspect > mediaAspect ? {\n                width: _this.containerRect.height * mediaAspect,\n                height: _this.containerRect.height\n              } : {\n                width: _this.containerRect.width,\n                height: _this.containerRect.width / mediaAspect\n              };\n              break;\n            case 'horizontal-cover':\n              renderedMediaSize = {\n                width: _this.containerRect.width,\n                height: _this.containerRect.width / mediaAspect\n              };\n              break;\n            case 'vertical-cover':\n              renderedMediaSize = {\n                width: _this.containerRect.height * mediaAspect,\n                height: _this.containerRect.height\n              };\n              break;\n            case 'auto-cover':\n              renderedMediaSize = naturalWidth > naturalHeight ? {\n                width: _this.containerRect.width,\n                height: _this.containerRect.width / mediaAspect\n              } : {\n                width: _this.containerRect.height * mediaAspect,\n                height: _this.containerRect.height\n              };\n              break;\n          }\n        } else {\n          renderedMediaSize = {\n            width: mediaRef.offsetWidth,\n            height: mediaRef.offsetHeight\n          };\n        }\n        _this.mediaSize = __assign(__assign({}, renderedMediaSize), {\n          naturalWidth: naturalWidth,\n          naturalHeight: naturalHeight\n        });\n        // set media size in the parent\n        if (_this.props.setMediaSize) {\n          _this.props.setMediaSize(_this.mediaSize);\n        }\n        var cropSize = _this.props.cropSize ? _this.props.cropSize : getCropSize(_this.mediaSize.width, _this.mediaSize.height, _this.containerRect.width, _this.containerRect.height, _this.props.aspect, _this.props.rotation);\n        if (((_e = _this.state.cropSize) === null || _e === void 0 ? void 0 : _e.height) !== cropSize.height || ((_f = _this.state.cropSize) === null || _f === void 0 ? void 0 : _f.width) !== cropSize.width) {\n          _this.props.onCropSizeChange && _this.props.onCropSizeChange(cropSize);\n        }\n        _this.setState({\n          cropSize: cropSize\n        }, _this.recomputeCropPosition);\n        // pass crop size to parent\n        if (_this.props.setCropSize) {\n          _this.props.setCropSize(cropSize);\n        }\n        return cropSize;\n      }\n    };\n    _this.onMouseDown = function (e) {\n      if (!_this.currentDoc) return;\n      e.preventDefault();\n      _this.currentDoc.addEventListener('mousemove', _this.onMouseMove);\n      _this.currentDoc.addEventListener('mouseup', _this.onDragStopped);\n      _this.onDragStart(Cropper.getMousePoint(e));\n    };\n    _this.onMouseMove = function (e) {\n      return _this.onDrag(Cropper.getMousePoint(e));\n    };\n    _this.onTouchStart = function (e) {\n      if (!_this.currentDoc) return;\n      _this.isTouching = true;\n      if (_this.props.onTouchRequest && !_this.props.onTouchRequest(e)) {\n        return;\n      }\n      _this.currentDoc.addEventListener('touchmove', _this.onTouchMove, {\n        passive: false\n      }); // iOS 11 now defaults to passive: true\n      _this.currentDoc.addEventListener('touchend', _this.onDragStopped);\n      if (e.touches.length === 2) {\n        _this.onPinchStart(e);\n      } else if (e.touches.length === 1) {\n        _this.onDragStart(Cropper.getTouchPoint(e.touches[0]));\n      }\n    };\n    _this.onTouchMove = function (e) {\n      // Prevent whole page from scrolling on iOS.\n      e.preventDefault();\n      if (e.touches.length === 2) {\n        _this.onPinchMove(e);\n      } else if (e.touches.length === 1) {\n        _this.onDrag(Cropper.getTouchPoint(e.touches[0]));\n      }\n    };\n    _this.onGestureStart = function (e) {\n      if (!_this.currentDoc) return;\n      e.preventDefault();\n      _this.currentDoc.addEventListener('gesturechange', _this.onGestureMove);\n      _this.currentDoc.addEventListener('gestureend', _this.onGestureEnd);\n      _this.gestureZoomStart = _this.props.zoom;\n      _this.gestureRotationStart = _this.props.rotation;\n    };\n    _this.onGestureMove = function (e) {\n      e.preventDefault();\n      if (_this.isTouching) {\n        // this is to avoid conflict between gesture and touch events\n        return;\n      }\n      var point = Cropper.getMousePoint(e);\n      var newZoom = _this.gestureZoomStart - 1 + e.scale;\n      _this.setNewZoom(newZoom, point, {\n        shouldUpdatePosition: true\n      });\n      if (_this.props.onRotationChange) {\n        var newRotation = _this.gestureRotationStart + e.rotation;\n        _this.props.onRotationChange(newRotation);\n      }\n    };\n    _this.onGestureEnd = function (e) {\n      _this.cleanEvents();\n    };\n    _this.onDragStart = function (_a) {\n      var _b, _c;\n      var x = _a.x,\n        y = _a.y;\n      _this.dragStartPosition = {\n        x: x,\n        y: y\n      };\n      _this.dragStartCrop = __assign({}, _this.props.crop);\n      (_c = (_b = _this.props).onInteractionStart) === null || _c === void 0 ? void 0 : _c.call(_b);\n    };\n    _this.onDrag = function (_a) {\n      var x = _a.x,\n        y = _a.y;\n      if (!_this.currentWindow) return;\n      if (_this.rafDragTimeout) _this.currentWindow.cancelAnimationFrame(_this.rafDragTimeout);\n      _this.rafDragTimeout = _this.currentWindow.requestAnimationFrame(function () {\n        if (!_this.state.cropSize) return;\n        if (x === undefined || y === undefined) return;\n        var offsetX = x - _this.dragStartPosition.x;\n        var offsetY = y - _this.dragStartPosition.y;\n        var requestedPosition = {\n          x: _this.dragStartCrop.x + offsetX,\n          y: _this.dragStartCrop.y + offsetY\n        };\n        var newPosition = _this.props.restrictPosition ? restrictPosition(requestedPosition, _this.mediaSize, _this.state.cropSize, _this.props.zoom, _this.props.rotation) : requestedPosition;\n        _this.props.onCropChange(newPosition);\n      });\n    };\n    _this.onDragStopped = function () {\n      var _a, _b;\n      _this.isTouching = false;\n      _this.cleanEvents();\n      _this.emitCropData();\n      (_b = (_a = _this.props).onInteractionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);\n    };\n    _this.onWheel = function (e) {\n      if (!_this.currentWindow) return;\n      if (_this.props.onWheelRequest && !_this.props.onWheelRequest(e)) {\n        return;\n      }\n      e.preventDefault();\n      var point = Cropper.getMousePoint(e);\n      var pixelY = normalizeWheel(e).pixelY;\n      var newZoom = _this.props.zoom - pixelY * _this.props.zoomSpeed / 200;\n      _this.setNewZoom(newZoom, point, {\n        shouldUpdatePosition: true\n      });\n      if (!_this.state.hasWheelJustStarted) {\n        _this.setState({\n          hasWheelJustStarted: true\n        }, function () {\n          var _a, _b;\n          return (_b = (_a = _this.props).onInteractionStart) === null || _b === void 0 ? void 0 : _b.call(_a);\n        });\n      }\n      if (_this.wheelTimer) {\n        clearTimeout(_this.wheelTimer);\n      }\n      _this.wheelTimer = _this.currentWindow.setTimeout(function () {\n        return _this.setState({\n          hasWheelJustStarted: false\n        }, function () {\n          var _a, _b;\n          return (_b = (_a = _this.props).onInteractionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);\n        });\n      }, 250);\n    };\n    _this.getPointOnContainer = function (_a) {\n      var x = _a.x,\n        y = _a.y;\n      if (!_this.containerRect) {\n        throw new Error('The Cropper is not mounted');\n      }\n      return {\n        x: _this.containerRect.width / 2 - (x - _this.containerRect.left),\n        y: _this.containerRect.height / 2 - (y - _this.containerRect.top)\n      };\n    };\n    _this.getPointOnMedia = function (_a) {\n      var x = _a.x,\n        y = _a.y;\n      var _b = _this.props,\n        crop = _b.crop,\n        zoom = _b.zoom;\n      return {\n        x: (x + crop.x) / zoom,\n        y: (y + crop.y) / zoom\n      };\n    };\n    _this.setNewZoom = function (zoom, point, _a) {\n      var _b = _a === void 0 ? {} : _a,\n        _c = _b.shouldUpdatePosition,\n        shouldUpdatePosition = _c === void 0 ? true : _c;\n      if (!_this.state.cropSize || !_this.props.onZoomChange) return;\n      var newZoom = clamp(zoom, _this.props.minZoom, _this.props.maxZoom);\n      if (shouldUpdatePosition) {\n        var zoomPoint = _this.getPointOnContainer(point);\n        var zoomTarget = _this.getPointOnMedia(zoomPoint);\n        var requestedPosition = {\n          x: zoomTarget.x * newZoom - zoomPoint.x,\n          y: zoomTarget.y * newZoom - zoomPoint.y\n        };\n        var newPosition = _this.props.restrictPosition ? restrictPosition(requestedPosition, _this.mediaSize, _this.state.cropSize, newZoom, _this.props.rotation) : requestedPosition;\n        _this.props.onCropChange(newPosition);\n      }\n      _this.props.onZoomChange(newZoom);\n    };\n    _this.getCropData = function () {\n      if (!_this.state.cropSize) {\n        return null;\n      }\n      // this is to ensure the crop is correctly restricted after a zoom back (https://github.com/ValentinH/react-easy-crop/issues/6)\n      var restrictedPosition = _this.props.restrictPosition ? restrictPosition(_this.props.crop, _this.mediaSize, _this.state.cropSize, _this.props.zoom, _this.props.rotation) : _this.props.crop;\n      return computeCroppedArea(restrictedPosition, _this.mediaSize, _this.state.cropSize, _this.getAspect(), _this.props.zoom, _this.props.rotation, _this.props.restrictPosition);\n    };\n    _this.emitCropData = function () {\n      var cropData = _this.getCropData();\n      if (!cropData) return;\n      var croppedAreaPercentages = cropData.croppedAreaPercentages,\n        croppedAreaPixels = cropData.croppedAreaPixels;\n      if (_this.props.onCropComplete) {\n        _this.props.onCropComplete(croppedAreaPercentages, croppedAreaPixels);\n      }\n      if (_this.props.onCropAreaChange) {\n        _this.props.onCropAreaChange(croppedAreaPercentages, croppedAreaPixels);\n      }\n    };\n    _this.emitCropAreaChange = function () {\n      var cropData = _this.getCropData();\n      if (!cropData) return;\n      var croppedAreaPercentages = cropData.croppedAreaPercentages,\n        croppedAreaPixels = cropData.croppedAreaPixels;\n      if (_this.props.onCropAreaChange) {\n        _this.props.onCropAreaChange(croppedAreaPercentages, croppedAreaPixels);\n      }\n    };\n    _this.recomputeCropPosition = function () {\n      if (!_this.state.cropSize) return;\n      var newPosition = _this.props.restrictPosition ? restrictPosition(_this.props.crop, _this.mediaSize, _this.state.cropSize, _this.props.zoom, _this.props.rotation) : _this.props.crop;\n      _this.props.onCropChange(newPosition);\n      _this.emitCropData();\n    };\n    return _this;\n  }\n  Cropper.prototype.componentDidMount = function () {\n    if (!this.currentDoc || !this.currentWindow) return;\n    if (this.containerRef) {\n      if (this.containerRef.ownerDocument) {\n        this.currentDoc = this.containerRef.ownerDocument;\n      }\n      if (this.currentDoc.defaultView) {\n        this.currentWindow = this.currentDoc.defaultView;\n      }\n      this.initResizeObserver();\n      // only add window resize listener if ResizeObserver is not supported. Otherwise, it would be redundant\n      if (typeof window.ResizeObserver === 'undefined') {\n        this.currentWindow.addEventListener('resize', this.computeSizes);\n      }\n      this.props.zoomWithScroll && this.containerRef.addEventListener('wheel', this.onWheel, {\n        passive: false\n      });\n      this.containerRef.addEventListener('gesturestart', this.onGestureStart);\n    }\n    if (!this.props.disableAutomaticStylesInjection) {\n      this.styleRef = this.currentDoc.createElement('style');\n      this.styleRef.setAttribute('type', 'text/css');\n      if (this.props.nonce) {\n        this.styleRef.setAttribute('nonce', this.props.nonce);\n      }\n      this.styleRef.innerHTML = css_248z;\n      this.currentDoc.head.appendChild(this.styleRef);\n    }\n    // when rendered via SSR, the image can already be loaded and its onLoad callback will never be called\n    if (this.imageRef.current && this.imageRef.current.complete) {\n      this.onMediaLoad();\n    }\n    // set image and video refs in the parent if the callbacks exist\n    if (this.props.setImageRef) {\n      this.props.setImageRef(this.imageRef);\n    }\n    if (this.props.setVideoRef) {\n      this.props.setVideoRef(this.videoRef);\n    }\n  };\n  Cropper.prototype.componentWillUnmount = function () {\n    var _a, _b;\n    if (!this.currentDoc || !this.currentWindow) return;\n    if (typeof window.ResizeObserver === 'undefined') {\n      this.currentWindow.removeEventListener('resize', this.computeSizes);\n    }\n    (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();\n    if (this.containerRef) {\n      this.containerRef.removeEventListener('gesturestart', this.preventZoomSafari);\n    }\n    if (this.styleRef) {\n      (_b = this.styleRef.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(this.styleRef);\n    }\n    this.cleanEvents();\n    this.props.zoomWithScroll && this.clearScrollEvent();\n  };\n  Cropper.prototype.componentDidUpdate = function (prevProps) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n    if (prevProps.rotation !== this.props.rotation) {\n      this.computeSizes();\n      this.recomputeCropPosition();\n    } else if (prevProps.aspect !== this.props.aspect) {\n      this.computeSizes();\n    } else if (prevProps.zoom !== this.props.zoom) {\n      this.recomputeCropPosition();\n    } else if (((_a = prevProps.cropSize) === null || _a === void 0 ? void 0 : _a.height) !== ((_b = this.props.cropSize) === null || _b === void 0 ? void 0 : _b.height) || ((_c = prevProps.cropSize) === null || _c === void 0 ? void 0 : _c.width) !== ((_d = this.props.cropSize) === null || _d === void 0 ? void 0 : _d.width)) {\n      this.computeSizes();\n    } else if (((_e = prevProps.crop) === null || _e === void 0 ? void 0 : _e.x) !== ((_f = this.props.crop) === null || _f === void 0 ? void 0 : _f.x) || ((_g = prevProps.crop) === null || _g === void 0 ? void 0 : _g.y) !== ((_h = this.props.crop) === null || _h === void 0 ? void 0 : _h.y)) {\n      this.emitCropAreaChange();\n    }\n    if (prevProps.zoomWithScroll !== this.props.zoomWithScroll && this.containerRef) {\n      this.props.zoomWithScroll ? this.containerRef.addEventListener('wheel', this.onWheel, {\n        passive: false\n      }) : this.clearScrollEvent();\n    }\n    if (prevProps.video !== this.props.video) {\n      (_j = this.videoRef.current) === null || _j === void 0 ? void 0 : _j.load();\n    }\n  };\n  Cropper.prototype.getAspect = function () {\n    var _a = this.props,\n      cropSize = _a.cropSize,\n      aspect = _a.aspect;\n    if (cropSize) {\n      return cropSize.width / cropSize.height;\n    }\n    return aspect;\n  };\n  Cropper.prototype.onPinchStart = function (e) {\n    var pointA = Cropper.getTouchPoint(e.touches[0]);\n    var pointB = Cropper.getTouchPoint(e.touches[1]);\n    this.lastPinchDistance = getDistanceBetweenPoints(pointA, pointB);\n    this.lastPinchRotation = getRotationBetweenPoints(pointA, pointB);\n    this.onDragStart(getCenter(pointA, pointB));\n  };\n  Cropper.prototype.onPinchMove = function (e) {\n    var _this = this;\n    if (!this.currentDoc || !this.currentWindow) return;\n    var pointA = Cropper.getTouchPoint(e.touches[0]);\n    var pointB = Cropper.getTouchPoint(e.touches[1]);\n    var center = getCenter(pointA, pointB);\n    this.onDrag(center);\n    if (this.rafPinchTimeout) this.currentWindow.cancelAnimationFrame(this.rafPinchTimeout);\n    this.rafPinchTimeout = this.currentWindow.requestAnimationFrame(function () {\n      var distance = getDistanceBetweenPoints(pointA, pointB);\n      var newZoom = _this.props.zoom * (distance / _this.lastPinchDistance);\n      _this.setNewZoom(newZoom, center, {\n        shouldUpdatePosition: false\n      });\n      _this.lastPinchDistance = distance;\n      var rotation = getRotationBetweenPoints(pointA, pointB);\n      var newRotation = _this.props.rotation + (rotation - _this.lastPinchRotation);\n      _this.props.onRotationChange && _this.props.onRotationChange(newRotation);\n      _this.lastPinchRotation = rotation;\n    });\n  };\n  Cropper.prototype.render = function () {\n    var _this = this;\n    var _a = this.props,\n      image = _a.image,\n      video = _a.video,\n      mediaProps = _a.mediaProps,\n      transform = _a.transform,\n      _b = _a.crop,\n      x = _b.x,\n      y = _b.y,\n      rotation = _a.rotation,\n      zoom = _a.zoom,\n      cropShape = _a.cropShape,\n      showGrid = _a.showGrid,\n      _c = _a.style,\n      containerStyle = _c.containerStyle,\n      cropAreaStyle = _c.cropAreaStyle,\n      mediaStyle = _c.mediaStyle,\n      _d = _a.classes,\n      containerClassName = _d.containerClassName,\n      cropAreaClassName = _d.cropAreaClassName,\n      mediaClassName = _d.mediaClassName,\n      objectFit = _a.objectFit;\n    return React.createElement(\"div\", {\n      onMouseDown: this.onMouseDown,\n      onTouchStart: this.onTouchStart,\n      ref: function ref(el) {\n        return _this.containerRef = el;\n      },\n      \"data-testid\": \"container\",\n      style: containerStyle,\n      className: classNames('reactEasyCrop_Container', containerClassName)\n    }, image ? React.createElement(\"img\", __assign({\n      alt: \"\",\n      className: classNames('reactEasyCrop_Image', objectFit === 'contain' && 'reactEasyCrop_Contain', objectFit === 'horizontal-cover' && 'reactEasyCrop_Cover_Horizontal', objectFit === 'vertical-cover' && 'reactEasyCrop_Cover_Vertical', objectFit === 'auto-cover' && (this.mediaSize.naturalWidth > this.mediaSize.naturalHeight ? 'reactEasyCrop_Cover_Horizontal' : 'reactEasyCrop_Cover_Vertical'), mediaClassName)\n    }, mediaProps, {\n      src: image,\n      ref: this.imageRef,\n      style: __assign(__assign({}, mediaStyle), {\n        transform: transform || \"translate(\".concat(x, \"px, \").concat(y, \"px) rotate(\").concat(rotation, \"deg) scale(\").concat(zoom, \")\")\n      }),\n      onLoad: this.onMediaLoad\n    })) : video && React.createElement(\"video\", __assign({\n      autoPlay: true,\n      loop: true,\n      muted: true,\n      className: classNames('reactEasyCrop_Video', objectFit === 'contain' && 'reactEasyCrop_Contain', objectFit === 'horizontal-cover' && 'reactEasyCrop_Cover_Horizontal', objectFit === 'vertical-cover' && 'reactEasyCrop_Cover_Vertical', objectFit === 'auto-cover' && (this.mediaSize.naturalWidth > this.mediaSize.naturalHeight ? 'reactEasyCrop_Cover_Horizontal' : 'reactEasyCrop_Cover_Vertical'), mediaClassName)\n    }, mediaProps, {\n      ref: this.videoRef,\n      onLoadedMetadata: this.onMediaLoad,\n      style: __assign(__assign({}, mediaStyle), {\n        transform: transform || \"translate(\".concat(x, \"px, \").concat(y, \"px) rotate(\").concat(rotation, \"deg) scale(\").concat(zoom, \")\")\n      }),\n      controls: false\n    }), (Array.isArray(video) ? video : [{\n      src: video\n    }]).map(function (item) {\n      return React.createElement(\"source\", __assign({\n        key: item.src\n      }, item));\n    })), this.state.cropSize && React.createElement(\"div\", {\n      style: __assign(__assign({}, cropAreaStyle), {\n        width: this.state.cropSize.width,\n        height: this.state.cropSize.height\n      }),\n      \"data-testid\": \"cropper\",\n      className: classNames('reactEasyCrop_CropArea', cropShape === 'round' && 'reactEasyCrop_CropAreaRound', showGrid && 'reactEasyCrop_CropAreaGrid', cropAreaClassName)\n    }));\n  };\n  Cropper.defaultProps = {\n    zoom: 1,\n    rotation: 0,\n    aspect: 4 / 3,\n    maxZoom: MAX_ZOOM,\n    minZoom: MIN_ZOOM,\n    cropShape: 'rect',\n    objectFit: 'contain',\n    showGrid: true,\n    style: {},\n    classes: {},\n    mediaProps: {},\n    zoomSpeed: 1,\n    restrictPosition: true,\n    zoomWithScroll: true\n  };\n  Cropper.getMousePoint = function (e) {\n    return {\n      x: Number(e.clientX),\n      y: Number(e.clientY)\n    };\n  };\n  Cropper.getTouchPoint = function (touch) {\n    return {\n      x: Number(touch.clientX),\n      y: Number(touch.clientY)\n    };\n  };\n  return Cropper;\n}(React.Component);\nexport { Cropper as default, getInitialCropFromCroppedAreaPercentages, getInitialCropFromCroppedAreaPixels };","map":{"version":3,"sources":["../src/helpers.ts","../src/Cropper.tsx"],"names":["mediaWidth","mediaHeight","containerWidth","containerHeight","aspect","width","height","rotation","fittingWidth","Math","min","fittingHeight","getMediaZoom","mediaSize","naturalWidth","naturalHeight","restrictPosition","position","cropSize","zoom","rotateSize","x","restrictPositionCoord","y","maxPosition","clamp","pointA","pointB","sqrt","pow","atan2","PI","crop","limitAreaFn","limitArea","noOp","mediaBBoxSize","mediaNaturalBBoxSize","croppedAreaPercentages","widthInPixels","round","heightInPixels","isImgWiderThanHigh","sizePixels","croppedAreaPixels","max","value","_max","minZoom","maxZoom","getZoomFromCroppedAreaPixels","mediaZoom","cropZoom","a","b","getRadianAngle","degreeValue","rotRad","abs","cos","sin","classNames","args","filter","length","join","trim","MIN_ZOOM","MAX_ZOOM","__extends","Component","Cropper","cropShape","objectFit","showGrid","style","classes","mediaProps","zoomSpeed","zoomWithScroll","_this","React","createRef","document","window","hasWheelJustStarted","currentDoc","currentWindow","containerRef","ownerDocument","defaultView","initResizeObserver","ResizeObserver","addEventListener","computeSizes","props","onWheel","passive","onGestureStart","disableAutomaticStylesInjection","styleRef","createElement","setAttribute","nonce","innerHTML","cssStyles","head","appendChild","imageRef","current","complete","onMediaLoad","setImageRef","setVideoRef","videoRef","removeEventListener","resizeObserver","preventZoomSafari","parentNode","removeChild","cleanEvents","clearScrollEvent","prevProps","recomputeCropPosition","emitCropAreaChange","video","isFirstResize","entries","observe","e","preventDefault","onMouseMove","onDragStopped","onTouchMove","onGestureMove","onGestureEnd","wheelTimer","clearTimeout","emitCropData","setInitialCrop","onMediaLoaded","initialCroppedAreaPercentages","getInitialCropFromCroppedAreaPercentages","onCropChange","onZoomChange","initialCroppedAreaPixels","getInitialCropFromCroppedAreaPixels","mediaRef","containerRect","getBoundingClientRect","containerAspect","videoWidth","videoHeight","isMediaScaledDown","offsetWidth","offsetHeight","mediaAspect","renderedMediaSize","setMediaSize","getCropSize","state","onCropSizeChange","setState","setCropSize","Number","clientX","clientY","touch","onDragStart","getMousePoint","onDrag","isTouching","onTouchRequest","touches","onPinchStart","getTouchPoint","onPinchMove","gestureZoomStart","gestureRotationStart","point","newZoom","scale","setNewZoom","shouldUpdatePosition","onRotationChange","newRotation","_a","dragStartPosition","dragStartCrop","__assign","onInteractionStart","rafDragTimeout","cancelAnimationFrame","requestAnimationFrame","undefined","offsetX","offsetY","requestedPosition","newPosition","onInteractionEnd","lastPinchDistance","getDistanceBetweenPoints","lastPinchRotation","getRotationBetweenPoints","getCenter","center","rafPinchTimeout","distance","onWheelRequest","normalizeWheel","pixelY","setTimeout","Error","left","top","_b","_c","zoomPoint","getPointOnContainer","zoomTarget","getPointOnMedia","restrictedPosition","computeCroppedArea","getAspect","cropData","getCropData","onCropComplete","onCropAreaChange","image","transform","containerStyle","cropAreaStyle","mediaStyle","_d","containerClassName","cropAreaClassName","mediaClassName","onMouseDown","onTouchStart","ref","el","className","alt","src","onLoad","autoPlay","loop","muted","onLoadedMetadata","controls","Array","isArray","map","item","key"],"mappings":"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","sourcesContent":["import { Area, MediaSize, Point, Size } from './types'\n\n/**\n * Compute the dimension of the crop area based on media size,\n * aspect ratio and optionally rotation\n */\nexport function getCropSize(\n  mediaWidth: number,\n  mediaHeight: number,\n  containerWidth: number,\n  containerHeight: number,\n  aspect: number,\n  rotation = 0\n): Size {\n  const { width, height } = rotateSize(mediaWidth, mediaHeight, rotation)\n  const fittingWidth = Math.min(width, containerWidth)\n  const fittingHeight = Math.min(height, containerHeight)\n\n  if (fittingWidth > fittingHeight * aspect) {\n    return {\n      width: fittingHeight * aspect,\n      height: fittingHeight,\n    }\n  }\n\n  return {\n    width: fittingWidth,\n    height: fittingWidth / aspect,\n  }\n}\n\n/**\n * Compute media zoom.\n * We fit the media into the container with \"max-width: 100%; max-height: 100%;\"\n */\nexport function getMediaZoom(mediaSize: MediaSize) {\n  // Take the axis with more pixels to improve accuracy\n  return mediaSize.width > mediaSize.height\n    ? mediaSize.width / mediaSize.naturalWidth\n    : mediaSize.height / mediaSize.naturalHeight\n}\n\n/**\n * Ensure a new media position stays in the crop area.\n */\nexport function restrictPosition(\n  position: Point,\n  mediaSize: Size,\n  cropSize: Size,\n  zoom: number,\n  rotation = 0\n): Point {\n  const { width, height } = rotateSize(mediaSize.width, mediaSize.height, rotation)\n\n  return {\n    x: restrictPositionCoord(position.x, width, cropSize.width, zoom),\n    y: restrictPositionCoord(position.y, height, cropSize.height, zoom),\n  }\n}\n\nfunction restrictPositionCoord(\n  position: number,\n  mediaSize: number,\n  cropSize: number,\n  zoom: number\n): number {\n  const maxPosition = (mediaSize * zoom) / 2 - cropSize / 2\n\n  return clamp(position, -maxPosition, maxPosition)\n}\n\nexport function getDistanceBetweenPoints(pointA: Point, pointB: Point) {\n  return Math.sqrt(Math.pow(pointA.y - pointB.y, 2) + Math.pow(pointA.x - pointB.x, 2))\n}\n\nexport function getRotationBetweenPoints(pointA: Point, pointB: Point) {\n  return (Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180) / Math.PI\n}\n\n/**\n * Compute the output cropped area of the media in percentages and pixels.\n * x/y are the top-left coordinates on the src media\n */\nexport function computeCroppedArea(\n  crop: Point,\n  mediaSize: MediaSize,\n  cropSize: Size,\n  aspect: number,\n  zoom: number,\n  rotation = 0,\n  restrictPosition = true\n): { croppedAreaPercentages: Area; croppedAreaPixels: Area } {\n  // if the media is rotated by the user, we cannot limit the position anymore\n  // as it might need to be negative.\n  const limitAreaFn = restrictPosition ? limitArea : noOp\n\n  const mediaBBoxSize = rotateSize(mediaSize.width, mediaSize.height, rotation)\n  const mediaNaturalBBoxSize = rotateSize(mediaSize.naturalWidth, mediaSize.naturalHeight, rotation)\n\n  // calculate the crop area in percentages\n  // in the rotated space\n  const croppedAreaPercentages = {\n    x: limitAreaFn(\n      100,\n      (((mediaBBoxSize.width - cropSize.width / zoom) / 2 - crop.x / zoom) / mediaBBoxSize.width) *\n        100\n    ),\n    y: limitAreaFn(\n      100,\n      (((mediaBBoxSize.height - cropSize.height / zoom) / 2 - crop.y / zoom) /\n        mediaBBoxSize.height) *\n        100\n    ),\n    width: limitAreaFn(100, ((cropSize.width / mediaBBoxSize.width) * 100) / zoom),\n    height: limitAreaFn(100, ((cropSize.height / mediaBBoxSize.height) * 100) / zoom),\n  }\n\n  // we compute the pixels size naively\n  const widthInPixels = Math.round(\n    limitAreaFn(\n      mediaNaturalBBoxSize.width,\n      (croppedAreaPercentages.width * mediaNaturalBBoxSize.width) / 100\n    )\n  )\n  const heightInPixels = Math.round(\n    limitAreaFn(\n      mediaNaturalBBoxSize.height,\n      (croppedAreaPercentages.height * mediaNaturalBBoxSize.height) / 100\n    )\n  )\n  const isImgWiderThanHigh = mediaNaturalBBoxSize.width >= mediaNaturalBBoxSize.height * aspect\n\n  // then we ensure the width and height exactly match the aspect (to avoid rounding approximations)\n  // if the media is wider than high, when zoom is 0, the crop height will be equals to image height\n  // thus we want to compute the width from the height and aspect for accuracy.\n  // Otherwise, we compute the height from width and aspect.\n  const sizePixels = isImgWiderThanHigh\n    ? {\n        width: Math.round(heightInPixels * aspect),\n        height: heightInPixels,\n      }\n    : {\n        width: widthInPixels,\n        height: Math.round(widthInPixels / aspect),\n      }\n\n  const croppedAreaPixels = {\n    ...sizePixels,\n    x: Math.round(\n      limitAreaFn(\n        mediaNaturalBBoxSize.width - sizePixels.width,\n        (croppedAreaPercentages.x * mediaNaturalBBoxSize.width) / 100\n      )\n    ),\n    y: Math.round(\n      limitAreaFn(\n        mediaNaturalBBoxSize.height - sizePixels.height,\n        (croppedAreaPercentages.y * mediaNaturalBBoxSize.height) / 100\n      )\n    ),\n  }\n\n  return { croppedAreaPercentages, croppedAreaPixels }\n}\n\n/**\n * Ensure the returned value is between 0 and max\n */\nfunction limitArea(max: number, value: number): number {\n  return Math.min(max, Math.max(0, value))\n}\n\nfunction noOp(_max: number, value: number) {\n  return value\n}\n\n/**\n * Compute crop and zoom from the croppedAreaPercentages.\n */\nexport function getInitialCropFromCroppedAreaPercentages(\n  croppedAreaPercentages: Area,\n  mediaSize: MediaSize,\n  rotation: number,\n  cropSize: Size,\n  minZoom: number,\n  maxZoom: number\n) {\n  const mediaBBoxSize = rotateSize(mediaSize.width, mediaSize.height, rotation)\n\n  // This is the inverse process of computeCroppedArea\n  const zoom = clamp(\n    (cropSize.width / mediaBBoxSize.width) * (100 / croppedAreaPercentages.width),\n    minZoom,\n    maxZoom\n  )\n\n  const crop = {\n    x:\n      (zoom * mediaBBoxSize.width) / 2 -\n      cropSize.width / 2 -\n      mediaBBoxSize.width * zoom * (croppedAreaPercentages.x / 100),\n    y:\n      (zoom * mediaBBoxSize.height) / 2 -\n      cropSize.height / 2 -\n      mediaBBoxSize.height * zoom * (croppedAreaPercentages.y / 100),\n  }\n\n  return { crop, zoom }\n}\n\n/**\n * Compute zoom from the croppedAreaPixels\n */\nfunction getZoomFromCroppedAreaPixels(\n  croppedAreaPixels: Area,\n  mediaSize: MediaSize,\n  cropSize: Size\n): number {\n  const mediaZoom = getMediaZoom(mediaSize)\n\n  return cropSize.height > cropSize.width\n    ? cropSize.height / (croppedAreaPixels.height * mediaZoom)\n    : cropSize.width / (croppedAreaPixels.width * mediaZoom)\n}\n\n/**\n * Compute crop and zoom from the croppedAreaPixels\n */\nexport function getInitialCropFromCroppedAreaPixels(\n  croppedAreaPixels: Area,\n  mediaSize: MediaSize,\n  rotation = 0,\n  cropSize: Size,\n  minZoom: number,\n  maxZoom: number\n): { crop: Point; zoom: number } {\n  const mediaNaturalBBoxSize = rotateSize(mediaSize.naturalWidth, mediaSize.naturalHeight, rotation)\n\n  const zoom = clamp(\n    getZoomFromCroppedAreaPixels(croppedAreaPixels, mediaSize, cropSize),\n    minZoom,\n    maxZoom\n  )\n\n  const cropZoom =\n    cropSize.height > cropSize.width\n      ? cropSize.height / croppedAreaPixels.height\n      : cropSize.width / croppedAreaPixels.width\n\n  const crop = {\n    x:\n      ((mediaNaturalBBoxSize.width - croppedAreaPixels.width) / 2 - croppedAreaPixels.x) * cropZoom,\n    y:\n      ((mediaNaturalBBoxSize.height - croppedAreaPixels.height) / 2 - croppedAreaPixels.y) *\n      cropZoom,\n  }\n  return { crop, zoom }\n}\n\n/**\n * Return the point that is the center of point a and b\n */\nexport function getCenter(a: Point, b: Point): Point {\n  return {\n    x: (b.x + a.x) / 2,\n    y: (b.y + a.y) / 2,\n  }\n}\n\nexport function getRadianAngle(degreeValue: number) {\n  return (degreeValue * Math.PI) / 180\n}\n\n/**\n * Returns the new bounding area of a rotated rectangle.\n */\nexport function rotateSize(width: number, height: number, rotation: number): Size {\n  const rotRad = getRadianAngle(rotation)\n\n  return {\n    width: Math.abs(Math.cos(rotRad) * width) + Math.abs(Math.sin(rotRad) * height),\n    height: Math.abs(Math.sin(rotRad) * width) + Math.abs(Math.cos(rotRad) * height),\n  }\n}\n\n/**\n * Clamp value between min and max\n */\nexport function clamp(value: number, min: number, max: number) {\n  return Math.min(Math.max(value, min), max)\n}\n\n/**\n * Combine multiple class names into a single string.\n */\nexport function classNames(...args: (boolean | string | number | undefined | void | null)[]) {\n  return args\n    .filter((value) => {\n      if (typeof value === 'string' && value.length > 0) {\n        return true\n      }\n\n      return false\n    })\n    .join(' ')\n    .trim()\n}\n","import React from 'react'\nimport normalizeWheel from 'normalize-wheel'\nimport { Area, MediaSize, Point, Size, VideoSrc } from './types'\nimport {\n  getCropSize,\n  restrictPosition,\n  getDistanceBetweenPoints,\n  getRotationBetweenPoints,\n  computeCroppedArea,\n  getCenter,\n  getInitialCropFromCroppedAreaPixels,\n  getInitialCropFromCroppedAreaPercentages,\n  classNames,\n  clamp,\n} from './helpers'\nimport cssStyles from './styles.css'\n\nexport type CropperProps = {\n  image?: string\n  video?: string | VideoSrc[]\n  transform?: string\n  crop: Point\n  zoom: number\n  rotation: number\n  aspect: number\n  minZoom: number\n  maxZoom: number\n  cropShape: 'rect' | 'round'\n  cropSize?: Size\n  objectFit?: 'contain' | 'horizontal-cover' | 'vertical-cover' | 'auto-cover'\n  showGrid?: boolean\n  zoomSpeed: number\n  zoomWithScroll?: boolean\n  onCropChange: (location: Point) => void\n  onZoomChange?: (zoom: number) => void\n  onRotationChange?: (rotation: number) => void\n  onCropComplete?: (croppedArea: Area, croppedAreaPixels: Area) => void\n  onCropAreaChange?: (croppedArea: Area, croppedAreaPixels: Area) => void\n  onCropSizeChange?: (cropSize: Size) => void\n  onInteractionStart?: () => void\n  onInteractionEnd?: () => void\n  onMediaLoaded?: (mediaSize: MediaSize) => void\n  style: {\n    containerStyle?: React.CSSProperties\n    mediaStyle?: React.CSSProperties\n    cropAreaStyle?: React.CSSProperties\n  }\n  classes: {\n    containerClassName?: string\n    mediaClassName?: string\n    cropAreaClassName?: string\n  }\n  restrictPosition: boolean\n  mediaProps: React.ImgHTMLAttributes<HTMLElement> | React.VideoHTMLAttributes<HTMLElement>\n  disableAutomaticStylesInjection?: boolean\n  initialCroppedAreaPixels?: Area\n  initialCroppedAreaPercentages?: Area\n  onTouchRequest?: (e: React.TouchEvent<HTMLDivElement>) => boolean\n  onWheelRequest?: (e: WheelEvent) => boolean\n  setImageRef?: (ref: React.RefObject<HTMLImageElement>) => void\n  setVideoRef?: (ref: React.RefObject<HTMLVideoElement>) => void\n  setMediaSize?: (size: MediaSize) => void\n  setCropSize?: (size: Size) => void\n  nonce?: string\n}\n\ntype State = {\n  cropSize: Size | null\n  hasWheelJustStarted: boolean\n}\n\nconst MIN_ZOOM = 1\nconst MAX_ZOOM = 3\n\ntype GestureEvent = UIEvent & {\n  rotation: number\n  scale: number\n  clientX: number\n  clientY: number\n}\n\nclass Cropper extends React.Component<CropperProps, State> {\n  static defaultProps = {\n    zoom: 1,\n    rotation: 0,\n    aspect: 4 / 3,\n    maxZoom: MAX_ZOOM,\n    minZoom: MIN_ZOOM,\n    cropShape: 'rect' as const,\n    objectFit: 'contain' as const,\n    showGrid: true,\n    style: {},\n    classes: {},\n    mediaProps: {},\n    zoomSpeed: 1,\n    restrictPosition: true,\n    zoomWithScroll: true,\n  }\n\n  imageRef: React.RefObject<HTMLImageElement> = React.createRef()\n  videoRef: React.RefObject<HTMLVideoElement> = React.createRef()\n  containerRef: HTMLDivElement | null = null\n  styleRef: HTMLStyleElement | null = null\n  containerRect: DOMRect | null = null\n  mediaSize: MediaSize = { width: 0, height: 0, naturalWidth: 0, naturalHeight: 0 }\n  dragStartPosition: Point = { x: 0, y: 0 }\n  dragStartCrop: Point = { x: 0, y: 0 }\n  gestureZoomStart = 0\n  gestureRotationStart = 0\n  isTouching = false\n  lastPinchDistance = 0\n  lastPinchRotation = 0\n  rafDragTimeout: number | null = null\n  rafPinchTimeout: number | null = null\n  wheelTimer: number | null = null\n  currentDoc: Document | null = typeof document !== 'undefined' ? document : null\n  currentWindow: Window | null = typeof window !== 'undefined' ? window : null\n  resizeObserver: ResizeObserver | null = null\n\n  state: State = {\n    cropSize: null,\n    hasWheelJustStarted: false,\n  }\n\n  componentDidMount() {\n    if (!this.currentDoc || !this.currentWindow) return\n    if (this.containerRef) {\n      if (this.containerRef.ownerDocument) {\n        this.currentDoc = this.containerRef.ownerDocument\n      }\n      if (this.currentDoc.defaultView) {\n        this.currentWindow = this.currentDoc.defaultView\n      }\n\n      this.initResizeObserver()\n      // only add window resize listener if ResizeObserver is not supported. Otherwise, it would be redundant\n      if (typeof window.ResizeObserver === 'undefined') {\n        this.currentWindow.addEventListener('resize', this.computeSizes)\n      }\n      this.props.zoomWithScroll &&\n        this.containerRef.addEventListener('wheel', this.onWheel, { passive: false })\n      this.containerRef.addEventListener('gesturestart', this.onGestureStart as EventListener)\n    }\n\n    if (!this.props.disableAutomaticStylesInjection) {\n      this.styleRef = this.currentDoc.createElement('style')\n      this.styleRef.setAttribute('type', 'text/css')\n      if (this.props.nonce) {\n        this.styleRef.setAttribute('nonce', this.props.nonce)\n      }\n      this.styleRef.innerHTML = cssStyles\n      this.currentDoc.head.appendChild(this.styleRef)\n    }\n\n    // when rendered via SSR, the image can already be loaded and its onLoad callback will never be called\n    if (this.imageRef.current && this.imageRef.current.complete) {\n      this.onMediaLoad()\n    }\n\n    // set image and video refs in the parent if the callbacks exist\n    if (this.props.setImageRef) {\n      this.props.setImageRef(this.imageRef)\n    }\n\n    if (this.props.setVideoRef) {\n      this.props.setVideoRef(this.videoRef)\n    }\n  }\n\n  componentWillUnmount() {\n    if (!this.currentDoc || !this.currentWindow) return\n    if (typeof window.ResizeObserver === 'undefined') {\n      this.currentWindow.removeEventListener('resize', this.computeSizes)\n    }\n    this.resizeObserver?.disconnect()\n    if (this.containerRef) {\n      this.containerRef.removeEventListener('gesturestart', this.preventZoomSafari)\n    }\n\n    if (this.styleRef) {\n      this.styleRef.parentNode?.removeChild(this.styleRef)\n    }\n\n    this.cleanEvents()\n    this.props.zoomWithScroll && this.clearScrollEvent()\n  }\n\n  componentDidUpdate(prevProps: CropperProps) {\n    if (prevProps.rotation !== this.props.rotation) {\n      this.computeSizes()\n      this.recomputeCropPosition()\n    } else if (prevProps.aspect !== this.props.aspect) {\n      this.computeSizes()\n    } else if (prevProps.zoom !== this.props.zoom) {\n      this.recomputeCropPosition()\n    } else if (\n      prevProps.cropSize?.height !== this.props.cropSize?.height ||\n      prevProps.cropSize?.width !== this.props.cropSize?.width\n    ) {\n      this.computeSizes()\n    } else if (\n      prevProps.crop?.x !== this.props.crop?.x ||\n      prevProps.crop?.y !== this.props.crop?.y\n    ) {\n      this.emitCropAreaChange()\n    }\n    if (prevProps.zoomWithScroll !== this.props.zoomWithScroll && this.containerRef) {\n      this.props.zoomWithScroll\n        ? this.containerRef.addEventListener('wheel', this.onWheel, { passive: false })\n        : this.clearScrollEvent()\n    }\n    if (prevProps.video !== this.props.video) {\n      this.videoRef.current?.load()\n    }\n  }\n\n  initResizeObserver = () => {\n    if (typeof window.ResizeObserver === 'undefined' || !this.containerRef) {\n      return\n    }\n    let isFirstResize = true\n    this.resizeObserver = new window.ResizeObserver((entries) => {\n      if (isFirstResize) {\n        isFirstResize = false // observe() is called on mount, we don't want to trigger a recompute on mount\n        return\n      }\n      this.computeSizes()\n    })\n    this.resizeObserver.observe(this.containerRef)\n  }\n\n  // this is to prevent Safari on iOS >= 10 to zoom the page\n  preventZoomSafari = (e: Event) => e.preventDefault()\n\n  cleanEvents = () => {\n    if (!this.currentDoc) return\n    this.currentDoc.removeEventListener('mousemove', this.onMouseMove)\n    this.currentDoc.removeEventListener('mouseup', this.onDragStopped)\n    this.currentDoc.removeEventListener('touchmove', this.onTouchMove)\n    this.currentDoc.removeEventListener('touchend', this.onDragStopped)\n    this.currentDoc.removeEventListener('gesturemove', this.onGestureMove as EventListener)\n    this.currentDoc.removeEventListener('gestureend', this.onGestureEnd as EventListener)\n  }\n\n  clearScrollEvent = () => {\n    if (this.containerRef) this.containerRef.removeEventListener('wheel', this.onWheel)\n    if (this.wheelTimer) {\n      clearTimeout(this.wheelTimer)\n    }\n  }\n\n  onMediaLoad = () => {\n    const cropSize = this.computeSizes()\n\n    if (cropSize) {\n      this.emitCropData()\n      this.setInitialCrop(cropSize)\n    }\n\n    if (this.props.onMediaLoaded) {\n      this.props.onMediaLoaded(this.mediaSize)\n    }\n  }\n\n  setInitialCrop = (cropSize: Size) => {\n    if (this.props.initialCroppedAreaPercentages) {\n      const { crop, zoom } = getInitialCropFromCroppedAreaPercentages(\n        this.props.initialCroppedAreaPercentages,\n        this.mediaSize,\n        this.props.rotation,\n        cropSize,\n        this.props.minZoom,\n        this.props.maxZoom\n      )\n\n      this.props.onCropChange(crop)\n      this.props.onZoomChange && this.props.onZoomChange(zoom)\n    } else if (this.props.initialCroppedAreaPixels) {\n      const { crop, zoom } = getInitialCropFromCroppedAreaPixels(\n        this.props.initialCroppedAreaPixels,\n        this.mediaSize,\n        this.props.rotation,\n        cropSize,\n        this.props.minZoom,\n        this.props.maxZoom\n      )\n\n      this.props.onCropChange(crop)\n      this.props.onZoomChange && this.props.onZoomChange(zoom)\n    }\n  }\n\n  getAspect() {\n    const { cropSize, aspect } = this.props\n    if (cropSize) {\n      return cropSize.width / cropSize.height\n    }\n    return aspect\n  }\n\n  computeSizes = () => {\n    const mediaRef = this.imageRef.current || this.videoRef.current\n\n    if (mediaRef && this.containerRef) {\n      this.containerRect = this.containerRef.getBoundingClientRect()\n      const containerAspect = this.containerRect.width / this.containerRect.height\n      const naturalWidth =\n        this.imageRef.current?.naturalWidth || this.videoRef.current?.videoWidth || 0\n      const naturalHeight =\n        this.imageRef.current?.naturalHeight || this.videoRef.current?.videoHeight || 0\n      const isMediaScaledDown =\n        mediaRef.offsetWidth < naturalWidth || mediaRef.offsetHeight < naturalHeight\n      const mediaAspect = naturalWidth / naturalHeight\n\n      // We do not rely on the offsetWidth/offsetHeight if the media is scaled down\n      // as the values they report are rounded. That will result in precision losses\n      // when calculating zoom. We use the fact that the media is positionned relative\n      // to the container. That allows us to use the container's dimensions\n      // and natural aspect ratio of the media to calculate accurate media size.\n      // However, for this to work, the container should not be rotated\n      let renderedMediaSize: Size\n\n      if (isMediaScaledDown) {\n        switch (this.props.objectFit) {\n          default:\n          case 'contain':\n            renderedMediaSize =\n              containerAspect > mediaAspect\n                ? {\n                    width: this.containerRect.height * mediaAspect,\n                    height: this.containerRect.height,\n                  }\n                : {\n                    width: this.containerRect.width,\n                    height: this.containerRect.width / mediaAspect,\n                  }\n            break\n          case 'horizontal-cover':\n            renderedMediaSize = {\n              width: this.containerRect.width,\n              height: this.containerRect.width / mediaAspect,\n            }\n            break\n          case 'vertical-cover':\n            renderedMediaSize = {\n              width: this.containerRect.height * mediaAspect,\n              height: this.containerRect.height,\n            }\n            break\n          case 'auto-cover':\n            renderedMediaSize =\n              naturalWidth > naturalHeight\n                ? {\n                    width: this.containerRect.width,\n                    height: this.containerRect.width / mediaAspect,\n                  }\n                : {\n                    width: this.containerRect.height * mediaAspect,\n                    height: this.containerRect.height,\n                  }\n            break\n        }\n      } else {\n        renderedMediaSize = {\n          width: mediaRef.offsetWidth,\n          height: mediaRef.offsetHeight,\n        }\n      }\n\n      this.mediaSize = {\n        ...renderedMediaSize,\n        naturalWidth,\n        naturalHeight,\n      }\n\n      // set media size in the parent\n      if (this.props.setMediaSize) {\n        this.props.setMediaSize(this.mediaSize)\n      }\n\n      const cropSize = this.props.cropSize\n        ? this.props.cropSize\n        : getCropSize(\n            this.mediaSize.width,\n            this.mediaSize.height,\n            this.containerRect.width,\n            this.containerRect.height,\n            this.props.aspect,\n            this.props.rotation\n          )\n\n      if (\n        this.state.cropSize?.height !== cropSize.height ||\n        this.state.cropSize?.width !== cropSize.width\n      ) {\n        this.props.onCropSizeChange && this.props.onCropSizeChange(cropSize)\n      }\n      this.setState({ cropSize }, this.recomputeCropPosition)\n      // pass crop size to parent\n      if (this.props.setCropSize) {\n        this.props.setCropSize(cropSize)\n      }\n\n      return cropSize\n    }\n  }\n\n  static getMousePoint = (e: MouseEvent | React.MouseEvent | GestureEvent) => ({\n    x: Number(e.clientX),\n    y: Number(e.clientY),\n  })\n\n  static getTouchPoint = (touch: Touch | React.Touch) => ({\n    x: Number(touch.clientX),\n    y: Number(touch.clientY),\n  })\n\n  onMouseDown = (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n    if (!this.currentDoc) return\n    e.preventDefault()\n    this.currentDoc.addEventListener('mousemove', this.onMouseMove)\n    this.currentDoc.addEventListener('mouseup', this.onDragStopped)\n    this.onDragStart(Cropper.getMousePoint(e))\n  }\n\n  onMouseMove = (e: MouseEvent) => this.onDrag(Cropper.getMousePoint(e))\n\n  onTouchStart = (e: React.TouchEvent<HTMLDivElement>) => {\n    if (!this.currentDoc) return\n    this.isTouching = true\n    if (this.props.onTouchRequest && !this.props.onTouchRequest(e)) {\n      return\n    }\n\n    this.currentDoc.addEventListener('touchmove', this.onTouchMove, { passive: false }) // iOS 11 now defaults to passive: true\n    this.currentDoc.addEventListener('touchend', this.onDragStopped)\n\n    if (e.touches.length === 2) {\n      this.onPinchStart(e)\n    } else if (e.touches.length === 1) {\n      this.onDragStart(Cropper.getTouchPoint(e.touches[0]))\n    }\n  }\n\n  onTouchMove = (e: TouchEvent) => {\n    // Prevent whole page from scrolling on iOS.\n    e.preventDefault()\n    if (e.touches.length === 2) {\n      this.onPinchMove(e)\n    } else if (e.touches.length === 1) {\n      this.onDrag(Cropper.getTouchPoint(e.touches[0]))\n    }\n  }\n\n  onGestureStart = (e: GestureEvent) => {\n    if (!this.currentDoc) return\n    e.preventDefault()\n    this.currentDoc.addEventListener('gesturechange', this.onGestureMove as EventListener)\n    this.currentDoc.addEventListener('gestureend', this.onGestureEnd as EventListener)\n    this.gestureZoomStart = this.props.zoom\n    this.gestureRotationStart = this.props.rotation\n  }\n\n  onGestureMove = (e: GestureEvent) => {\n    e.preventDefault()\n    if (this.isTouching) {\n      // this is to avoid conflict between gesture and touch events\n      return\n    }\n\n    const point = Cropper.getMousePoint(e)\n    const newZoom = this.gestureZoomStart - 1 + e.scale\n    this.setNewZoom(newZoom, point, { shouldUpdatePosition: true })\n    if (this.props.onRotationChange) {\n      const newRotation = this.gestureRotationStart + e.rotation\n      this.props.onRotationChange(newRotation)\n    }\n  }\n\n  onGestureEnd = (e: GestureEvent) => {\n    this.cleanEvents()\n  }\n\n  onDragStart = ({ x, y }: Point) => {\n    this.dragStartPosition = { x, y }\n    this.dragStartCrop = { ...this.props.crop }\n    this.props.onInteractionStart?.()\n  }\n\n  onDrag = ({ x, y }: Point) => {\n    if (!this.currentWindow) return\n    if (this.rafDragTimeout) this.currentWindow.cancelAnimationFrame(this.rafDragTimeout)\n\n    this.rafDragTimeout = this.currentWindow.requestAnimationFrame(() => {\n      if (!this.state.cropSize) return\n      if (x === undefined || y === undefined) return\n      const offsetX = x - this.dragStartPosition.x\n      const offsetY = y - this.dragStartPosition.y\n      const requestedPosition = {\n        x: this.dragStartCrop.x + offsetX,\n        y: this.dragStartCrop.y + offsetY,\n      }\n\n      const newPosition = this.props.restrictPosition\n        ? restrictPosition(\n            requestedPosition,\n            this.mediaSize,\n            this.state.cropSize,\n            this.props.zoom,\n            this.props.rotation\n          )\n        : requestedPosition\n      this.props.onCropChange(newPosition)\n    })\n  }\n\n  onDragStopped = () => {\n    this.isTouching = false\n    this.cleanEvents()\n    this.emitCropData()\n    this.props.onInteractionEnd?.()\n  }\n\n  onPinchStart(e: React.TouchEvent<HTMLDivElement>) {\n    const pointA = Cropper.getTouchPoint(e.touches[0])\n    const pointB = Cropper.getTouchPoint(e.touches[1])\n    this.lastPinchDistance = getDistanceBetweenPoints(pointA, pointB)\n    this.lastPinchRotation = getRotationBetweenPoints(pointA, pointB)\n    this.onDragStart(getCenter(pointA, pointB))\n  }\n\n  onPinchMove(e: TouchEvent) {\n    if (!this.currentDoc || !this.currentWindow) return\n    const pointA = Cropper.getTouchPoint(e.touches[0])\n    const pointB = Cropper.getTouchPoint(e.touches[1])\n    const center = getCenter(pointA, pointB)\n    this.onDrag(center)\n\n    if (this.rafPinchTimeout) this.currentWindow.cancelAnimationFrame(this.rafPinchTimeout)\n    this.rafPinchTimeout = this.currentWindow.requestAnimationFrame(() => {\n      const distance = getDistanceBetweenPoints(pointA, pointB)\n      const newZoom = this.props.zoom * (distance / this.lastPinchDistance)\n      this.setNewZoom(newZoom, center, { shouldUpdatePosition: false })\n      this.lastPinchDistance = distance\n\n      const rotation = getRotationBetweenPoints(pointA, pointB)\n      const newRotation = this.props.rotation + (rotation - this.lastPinchRotation)\n      this.props.onRotationChange && this.props.onRotationChange(newRotation)\n      this.lastPinchRotation = rotation\n    })\n  }\n\n  onWheel = (e: WheelEvent) => {\n    if (!this.currentWindow) return\n    if (this.props.onWheelRequest && !this.props.onWheelRequest(e)) {\n      return\n    }\n\n    e.preventDefault()\n    const point = Cropper.getMousePoint(e)\n    const { pixelY } = normalizeWheel(e)\n    const newZoom = this.props.zoom - (pixelY * this.props.zoomSpeed) / 200\n    this.setNewZoom(newZoom, point, { shouldUpdatePosition: true })\n\n    if (!this.state.hasWheelJustStarted) {\n      this.setState({ hasWheelJustStarted: true }, () => this.props.onInteractionStart?.())\n    }\n\n    if (this.wheelTimer) {\n      clearTimeout(this.wheelTimer)\n    }\n    this.wheelTimer = this.currentWindow.setTimeout(\n      () => this.setState({ hasWheelJustStarted: false }, () => this.props.onInteractionEnd?.()),\n      250\n    )\n  }\n\n  getPointOnContainer = ({ x, y }: Point) => {\n    if (!this.containerRect) {\n      throw new Error('The Cropper is not mounted')\n    }\n    return {\n      x: this.containerRect.width / 2 - (x - this.containerRect.left),\n      y: this.containerRect.height / 2 - (y - this.containerRect.top),\n    }\n  }\n\n  getPointOnMedia = ({ x, y }: Point) => {\n    const { crop, zoom } = this.props\n    return {\n      x: (x + crop.x) / zoom,\n      y: (y + crop.y) / zoom,\n    }\n  }\n\n  setNewZoom = (zoom: number, point: Point, { shouldUpdatePosition = true } = {}) => {\n    if (!this.state.cropSize || !this.props.onZoomChange) return\n\n    const newZoom = clamp(zoom, this.props.minZoom, this.props.maxZoom)\n\n    if (shouldUpdatePosition) {\n      const zoomPoint = this.getPointOnContainer(point)\n      const zoomTarget = this.getPointOnMedia(zoomPoint)\n      const requestedPosition = {\n        x: zoomTarget.x * newZoom - zoomPoint.x,\n        y: zoomTarget.y * newZoom - zoomPoint.y,\n      }\n\n      const newPosition = this.props.restrictPosition\n        ? restrictPosition(\n            requestedPosition,\n            this.mediaSize,\n            this.state.cropSize,\n            newZoom,\n            this.props.rotation\n          )\n        : requestedPosition\n\n      this.props.onCropChange(newPosition)\n    }\n    this.props.onZoomChange(newZoom)\n  }\n\n  getCropData = () => {\n    if (!this.state.cropSize) {\n      return null\n    }\n\n    // this is to ensure the crop is correctly restricted after a zoom back (https://github.com/ValentinH/react-easy-crop/issues/6)\n    const restrictedPosition = this.props.restrictPosition\n      ? restrictPosition(\n          this.props.crop,\n          this.mediaSize,\n          this.state.cropSize,\n          this.props.zoom,\n          this.props.rotation\n        )\n      : this.props.crop\n    return computeCroppedArea(\n      restrictedPosition,\n      this.mediaSize,\n      this.state.cropSize,\n      this.getAspect(),\n      this.props.zoom,\n      this.props.rotation,\n      this.props.restrictPosition\n    )\n  }\n\n  emitCropData = () => {\n    const cropData = this.getCropData()\n    if (!cropData) return\n\n    const { croppedAreaPercentages, croppedAreaPixels } = cropData\n    if (this.props.onCropComplete) {\n      this.props.onCropComplete(croppedAreaPercentages, croppedAreaPixels)\n    }\n\n    if (this.props.onCropAreaChange) {\n      this.props.onCropAreaChange(croppedAreaPercentages, croppedAreaPixels)\n    }\n  }\n\n  emitCropAreaChange = () => {\n    const cropData = this.getCropData()\n    if (!cropData) return\n\n    const { croppedAreaPercentages, croppedAreaPixels } = cropData\n    if (this.props.onCropAreaChange) {\n      this.props.onCropAreaChange(croppedAreaPercentages, croppedAreaPixels)\n    }\n  }\n\n  recomputeCropPosition = () => {\n    if (!this.state.cropSize) return\n\n    const newPosition = this.props.restrictPosition\n      ? restrictPosition(\n          this.props.crop,\n          this.mediaSize,\n          this.state.cropSize,\n          this.props.zoom,\n          this.props.rotation\n        )\n      : this.props.crop\n\n    this.props.onCropChange(newPosition)\n    this.emitCropData()\n  }\n\n  render() {\n    const {\n      image,\n      video,\n      mediaProps,\n      transform,\n      crop: { x, y },\n      rotation,\n      zoom,\n      cropShape,\n      showGrid,\n      style: { containerStyle, cropAreaStyle, mediaStyle },\n      classes: { containerClassName, cropAreaClassName, mediaClassName },\n      objectFit,\n    } = this.props\n\n    return (\n      <div\n        onMouseDown={this.onMouseDown}\n        onTouchStart={this.onTouchStart}\n        ref={(el) => (this.containerRef = el)}\n        data-testid=\"container\"\n        style={containerStyle}\n        className={classNames('reactEasyCrop_Container', containerClassName)}\n      >\n        {image ? (\n          <img\n            alt=\"\"\n            className={classNames(\n              'reactEasyCrop_Image',\n              objectFit === 'contain' && 'reactEasyCrop_Contain',\n              objectFit === 'horizontal-cover' && 'reactEasyCrop_Cover_Horizontal',\n              objectFit === 'vertical-cover' && 'reactEasyCrop_Cover_Vertical',\n              objectFit === 'auto-cover' &&\n                (this.mediaSize.naturalWidth > this.mediaSize.naturalHeight\n                  ? 'reactEasyCrop_Cover_Horizontal'\n                  : 'reactEasyCrop_Cover_Vertical'),\n              mediaClassName\n            )}\n            {...(mediaProps as React.ImgHTMLAttributes<HTMLElement>)}\n            src={image}\n            ref={this.imageRef}\n            style={{\n              ...mediaStyle,\n              transform:\n                transform || `translate(${x}px, ${y}px) rotate(${rotation}deg) scale(${zoom})`,\n            }}\n            onLoad={this.onMediaLoad}\n          />\n        ) : (\n          video && (\n            <video\n              autoPlay\n              loop\n              muted={true}\n              className={classNames(\n                'reactEasyCrop_Video',\n                objectFit === 'contain' && 'reactEasyCrop_Contain',\n                objectFit === 'horizontal-cover' && 'reactEasyCrop_Cover_Horizontal',\n                objectFit === 'vertical-cover' && 'reactEasyCrop_Cover_Vertical',\n                objectFit === 'auto-cover' &&\n                  (this.mediaSize.naturalWidth > this.mediaSize.naturalHeight\n                    ? 'reactEasyCrop_Cover_Horizontal'\n                    : 'reactEasyCrop_Cover_Vertical'),\n                mediaClassName\n              )}\n              {...mediaProps}\n              ref={this.videoRef}\n              onLoadedMetadata={this.onMediaLoad}\n              style={{\n                ...mediaStyle,\n                transform:\n                  transform || `translate(${x}px, ${y}px) rotate(${rotation}deg) scale(${zoom})`,\n              }}\n              controls={false}\n            >\n              {(Array.isArray(video) ? video : [{ src: video }]).map((item) => (\n                <source key={item.src} {...item} />\n              ))}\n            </video>\n          )\n        )}\n        {this.state.cropSize && (\n          <div\n            style={{\n              ...cropAreaStyle,\n              width: this.state.cropSize.width,\n              height: this.state.cropSize.height,\n            }}\n            data-testid=\"cropper\"\n            className={classNames(\n              'reactEasyCrop_CropArea',\n              cropShape === 'round' && 'reactEasyCrop_CropAreaRound',\n              showGrid && 'reactEasyCrop_CropAreaGrid',\n              cropAreaClassName\n            )}\n          />\n        )}\n      </div>\n    )\n  }\n}\n\nexport default Cropper\n"]},"metadata":{},"sourceType":"module"}